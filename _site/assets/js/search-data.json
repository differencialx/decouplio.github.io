{"0": {
    "doc": "With addition service params",
    "title": "Example with additional service params",
    "content": "require 'decouplio' class Semantic def self.call(ctx, ms, semantic:, error_message:) ms.status = semantic ms.add_error(semantic, error_message) end end class SomeActionSemantic &lt; Decouplio::Action logic do step :step_one fail Semantic, semantic: :bad_request, error_message: 'Bad request' step :step_two end def step_one ctx[:step_one] = c.step_one_param end def step_two ctx[:step_two] = 'Success' end def fail_one ctx[:fail_one] = 'Failure' end end success_action = SomeActionSemantic.call(step_one_param: true) failure_action = SomeActionSemantic.call(step_one_param: false) success_action # =&gt; # Result: success # RailwayFlow: # step_one -&gt; step_two # Context: # :step_one_param =&gt; true # :step_one =&gt; true # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE failure_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; Semantic # Context: # :step_one_param =&gt; false # :step_one =&gt; false # Status: :bad_request # Errors: # :bad_request =&gt; [\"Bad request\"] . ",
    "url": "http://localhost:4000/decouplio.github.io/additional_service_params/#example-with-additional-service-params",
    "relUrl": "/additional_service_params/#example-with-additional-service-params"
  },"1": {
    "doc": "With addition service params",
    "title": "With addition service params",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/additional_service_params/",
    "relUrl": "/additional_service_params/"
  },"2": {
    "doc": "Using context key",
    "title": "Octo by ctx_key",
    "content": "ctx_key option will use value from action context placed under specified key. class OctoByKey &lt; Decouplio::Action logic do octo :octo_name, ctx_key: :octo_key do on :octo_key1, :step_one on :octo_key2, :step_two end end def step_one ctx[:step_one] = 'step_one success' end def step_two ctx[:step_two] = 'step_two success' end end OctoByKey.call(octo_key: :octo_key1) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key1 -&gt; step_one # Context: # :octo_key =&gt; :octo_key1 # :step_one =&gt; \"step_one success\" # Status: NONE # Errors: # NONE OctoByKey.call(octo_key: :octo_key2) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key2 -&gt; step_two # Context: # :octo_key =&gt; :octo_key2 # :step_two =&gt; \"step_two success\" # Status: NONE # Errors: # NONE . flowchart LR; A(start)--&gt;B(octo_name); B(octo_name)--&gt;|when :octo_key1|C(step_one); B(octo_name)--&gt;|when :octo_key2|D(step_two); C(step_one)--&gt;|success track|E(finish_success); D(step_two)--&gt;|success track|E(finish_success); ",
    "url": "http://localhost:4000/decouplio.github.io/octo_by_ctx_key/#octo-by-ctx_key",
    "relUrl": "/octo_by_ctx_key/#octo-by-ctx_key"
  },"3": {
    "doc": "Using context key",
    "title": "Using context key",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/octo_by_ctx_key/",
    "relUrl": "/octo_by_ctx_key/"
  },"4": {
    "doc": "Using method",
    "title": "Using method",
    "content": "Octo key will be retrieved from method execution result. class OctoByMethod &lt; Decouplio::Action logic do octo :octo_name, method: :retrieve_octo_key do on :octo_key1, :step_one on :octo_key2, :step_two end end def step_one ctx[:step_one] = 'step_one success' end def step_two ctx[:step_two] = 'step_two success' end def retrieve_octo_key c.octo_key end end OctoByMethod.call(octo_key: :octo_key1) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key1 -&gt; step_one # Context: # :octo_key =&gt; :octo_key1 # :step_one =&gt; \"step_one success\" # Status: NONE # Errors: # NONE OctoByMethod.call(octo_key: :octo_key2) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key2 -&gt; step_two # Context: # :octo_key =&gt; :octo_key2 # :step_two =&gt; \"step_two success\" # Status: NONE # Errors: # NONE . flowchart LR; A(start)--&gt;B(octo_name); B(octo_name)--&gt;|when :octo_key1|C(step_one); B(octo_name)--&gt;|when :octo_key2|D(step_two); C(step_one)--&gt;|success track|E(finish_success); D(step_two)--&gt;|success track|E(finish_success); ",
    "url": "http://localhost:4000/decouplio.github.io/octo_by_method/",
    "relUrl": "/octo_by_method/"
  },"5": {
    "doc": "Custom MetaStore",
    "title": "Custom MetaStore",
    "content": "You always can define your own meta store, which will suit for you. Just create new class AND Set it for action using meta_store_class method . NOTE: To avoid setting your custom meta_store for all action, you can create a base class and set it there and just inherit your action from it. class CustomMetaStore attr_reader :whatever def initialize @whatever = [] end def add_whatever(element) @whatever &lt;&lt; element end def to_s &lt;&lt;~METASTORE Whatever: #{@whatever.inspect} METASTORE end end class BaseCustomMetaStore &lt; Decouplio::Action meta_store_class CustomMetaStore end class CustomMetaStoreAction &lt; BaseCustomMetaStore logic do step :add_whatever end def add_whatever(**) ms.add_whatever(42) ms.add_whatever('Whatever') end end result = CustomMetaStoreAction.call result # Result: success # RailwayFlow: # add_meta_status -&gt; add_meta_error -&gt; add_whatever # Context: # NONE # Whatever: # [42, \"Whatever\"] . ",
    "url": "http://localhost:4000/decouplio.github.io/custom_metastore/",
    "relUrl": "/custom_metastore/"
  },"6": {
    "doc": "Default MetaStore",
    "title": "Default MetaStore",
    "content": "This is how DefaultMetaStore looks like. module Decouplio class DefaultMetaStore attr_accessor :status attr_reader :errors def initialize @errors = {} @status = nil end def add_error(key, messages) @errors.store( key, (@errors[key] || []) + [messages].flatten ) end def to_s &lt;&lt;~METASTORE Status: #{@status || 'NONE'} Errors: #{errors_string} METASTORE end private def errors_string return 'NONE' if @errors.empty? @errors.map do |k, v| \"#{k.inspect} =&gt; #{v.inspect}\" end.join(\"\\n \") end end end . ",
    "url": "http://localhost:4000/decouplio.github.io/default_metastore/",
    "relUrl": "/default_metastore/"
  },"7": {
    "doc": "Default MetaStore",
    "title": "How to use",
    "content": "For each new action call new meta_store will be initialized. You can access meta_store by calling ms method inside stepâ€™s methods. Also meta_store will be passed as a second argument into Service as a step. Decouplio::DefaultMetaStore implements basic three basic methods . | add_error - adds error to meta_store | status= - sets status or action. It can be used to make a decision what should be done next, as success or failure action result is not enough sometimes. | to_s - this method should be implemented if you want to have good looking console output of action, otherwise it will be printed as default object. | . require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one end def step_one(**) FAIL end def fail_one(**) ms.status = :step_one_failure ms.add_error(:something_went_wrong, 'Something went wrong') end end action = SomeAction.call action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; fail_one # Context: NONE # Status: step_one_failure # Errors: # :something_went_wrong =&gt; [\"Something went wrong\"] action.ms.errors # =&gt; # {:something_went_wrong=&gt;[\"Something went wrong\"]} action.ms.status # =&gt; # step_one_failure . ",
    "url": "http://localhost:4000/decouplio.github.io/default_metastore/#how-to-use",
    "relUrl": "/default_metastore/#how-to-use"
  },"8": {
    "doc": "Fail",
    "title": "Fail",
    "content": "fail is the special type of step to mark failure track . ",
    "url": "http://localhost:4000/decouplio.github.io/fail/",
    "relUrl": "/fail/"
  },"9": {
    "doc": "Fail",
    "title": "Signature",
    "content": "fail(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/fail/#signature",
    "relUrl": "/fail/#signature"
  },"10": {
    "doc": "Fail",
    "title": "Behavior",
    "content": ". | when step method(#fail_one) returns truthy or falsy value then it goes to failure track(fail_two step) unless on_success: or on_failure: option were specified(see on_success, on_failure docs) | . require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one fail :fail_two end def step_one c.param_for_step_one end def fail_one ctx[:action_failed] = true end def fail_two ctx[:fail_two] = 'Failure' end end success_action = SomeAction.call(param_for_step_one: true) failure_action = SomeAction.call(param_for_step_one: false) success_action # =&gt; # Result: success # RailwayFlow: # step_one # Context: # :param_for_step_one =&gt; true # Status: NONE # Errors: # NONE failure_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; fail_one -&gt; fail_two # Context: # :param_for_step_one =&gt; false # :action_failed =&gt; true # :fail_two =&gt; \"Failure\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(finish_success); 2(step_one)--&gt;|failure track|4(fail_one); 4(fail_one)--&gt;|failure track|5(fail_two); 5(fail_two)--&gt;|failure track|F(finish_failure); ",
    "url": "http://localhost:4000/decouplio.github.io/fail/#behavior",
    "relUrl": "/fail/#behavior"
  },"11": {
    "doc": "finish_him",
    "title": "finish_him",
    "content": "Stops action execution. finish_him has different option values for different steps, see table below. | Step type/Available values | :on_success | :on_failure | :on_error | true | . | step | YES | YES | YES | NO | . | fail | YES | YES | YES | YES - will stop action execution anyway | . | pass | YES | YES | YES | YES - will stop action execution anyway | . | wrap | YES | YES | YES | NO | . | octo - not allowed | NO | NO | NO | NO | . # ... logic do step :step_one, finish_him: :on_success # will stop action execution step :step_two end def step_one true end . # ... logic do step :step_one, finish_him: :on_failure # will stop action execution step :step_two fail :fail_one end def step_one false end . # ... logic do step :step_one, finish_him: :on_error # will stop action execution step :step_two fail :fail_one end def step_one raise 'Something went wrong' end . # ... logic do step :step_one pass :pass_one, finish_him: :true fail :fail_one, finish_him: :true step :final fail :fail_final end def step_one [true, false].sample end def fail_one # doesn't matter what value will be returned by step method, action executions will be stopped end def pass_one # doesn't matter what value will be returned by step method, action executions will be stopped end . ",
    "url": "http://localhost:4000/decouplio.github.io/finish_him/",
    "relUrl": "/finish_him/"
  },"12": {
    "doc": "if/unless",
    "title": "if/unless",
    "content": "Can be used if you need to perform step conditionally . if/unless is allowed for step, fail, pass, wrap, octo . # ... logic do step :step_one, if: :some_condition? # step will be executed if some_condition? method returns truthy value step :step_two, unless: :another_condition? # step will be executed unless another_condition? method returns falsy value step :step_three end def step_one true end def step_two true end def some_condition? c.some_value == 'some_value' end def another_condition? c.another_value == 'another_value' end # ... ",
    "url": "http://localhost:4000/decouplio.github.io/if_unless/",
    "relUrl": "/if_unless/"
  },"13": {
    "doc": "Home",
    "title": "Decouplio",
    "content": "Decouplio is a zero dependency, thread safe and framework agnostic gem designed to encapsulate application business logic. Itâ€™s reverse engineered through TDD and inspired by such frameworks and gems like Trailblazer, Interactor. ",
    "url": "http://localhost:4000/decouplio.github.io/#decouplio",
    "relUrl": "/#decouplio"
  },"14": {
    "doc": "Home",
    "title": "How to install?",
    "content": "gem install decouplio --pre . Gemfile . gem 'decouplio', '~&gt; 1.0.0rc' . ",
    "url": "http://localhost:4000/decouplio.github.io/#how-to-install",
    "relUrl": "/#how-to-install"
  },"15": {
    "doc": "Home",
    "title": "Compatibility",
    "content": "Ruby: . | 2.7 | 3.0 | . ",
    "url": "http://localhost:4000/decouplio.github.io/#compatibility",
    "relUrl": "/#compatibility"
  },"16": {
    "doc": "Home",
    "title": "Quick reference to docs",
    "content": "| Options/Step type | step | fail | pass | wrap | octo | resq | . | Â  | on_success | on_success | Â  | on_success | on_success | - | . | Â  | on_failure | on_failure | Â  | on_failure | on_failure | - | . | Â  | on_error | on_error | on_error | on_error | on_error | - | . | Â  | finish_him | finish_him | finish_him | finish_him | Â  | - | . | Â  | if/unless | if/unless | if/unless | if/unless | if/unless | - | . ",
    "url": "http://localhost:4000/decouplio.github.io/#quick-reference-to-docs",
    "relUrl": "/#quick-reference-to-docs"
  },"17": {
    "doc": "Home",
    "title": "Quick start",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/#quick-start",
    "relUrl": "/#quick-start"
  },"18": {
    "doc": "Home",
    "title": "What should you know before start?",
    "content": "Action . Action is a class which encapsulates business logic. To create one just create a class and inherit it from Decouplio::Action class . require 'decouplio' class MyAction &lt; Decouplio::Action end . Logic block . Block inside Action which contains definition of business logic. require 'decouplio' class MyAction &lt; Decouplio::Action logic do # logic block end end . Step . Step is an atomic part of business logic and it defines inside Logic block. require 'decouplio' class MyAction &lt; Decouplio::Action logic do step :hello_world end def hello_world ctx[:result] = 'Hello world' end end MyAction.call[:result] # =&gt; Hello world . | Step types | . | step | . | fail | . | pass | . | wrap | . | octo | . | resq | . Context . Action context is an object which is used to share data between steps. Itâ€™s accessible only inside step. | To access the action context inside step you need to call ctx method | ctx behaves like a Hash. | To assign some value to ctx just do ctx[:some_key] = 'some value' | To access ctx value use ctx[:some_value] or use a shortcut c.some_value | . NOTE: you canâ€™t assign context value using c.&lt;some key&gt; shortcut. require 'decouplio' class CtxIntroduction &lt; Decouplio::Action logic do step :calculate_result end def calculate_result ctx[:result] = c.one + c.two # OR # c[:result] = c[:one] + c[:two] #OR # ctx[:result] = ctx[:one] + ctx[:two] end end action_result = CtxIntroduction.call(one: 1, two: 2) action_result[:result] # =&gt; 3 . Success/Failure track . Execution flow of action is changing depending on step result. | If step returns truthy value(not nil|false), when next success track step will be executed. | If step returns falsy value(nil|false), when next failure track step will be executed. | . | Success track | Failure track | . | step | fail | . | pass | Â  | . | wrap | Â  | . | octo | Â  | . require 'decouplio' class Divider &lt; Decouplio::Action logic do step :validate_divider step :divide fail :failure_message end def validate_divider !ctx[:divider].zero? end def divide ctx[:result] = c.number / c.divider end def failure_message ctx[:error_message] = 'Division by zero is not allowed' end end divider_success = Divider.call(number: 4, divider: 2) divider_success.success? # =&gt; true divider_success.failure? # =&gt; false divider_success[:result] # =&gt; 2 divider_success[:error_message] # =&gt; nil divider_success.railway_flow # =&gt; [:validate_divider, :divide] puts divider_success # =&gt; # Result: success # RailwayFlow: # validate_divider -&gt; divide # Context: # :number =&gt; 4 # :divider =&gt; 2 # :result =&gt; 2 # Status: NONE # Errors: # NONE divider_failure = Divider.call(number: 4, divider: 0) divider_failure.success? #=&gt; false divider_failure.failure? #=&gt; true divider_failure[:result] # =&gt; nil divider_failure[:error_message] # =&gt; 'Division by zero is not allowed' divider_failure.railway_flow# =&gt; [:validate_divider, :failure_message] divider_failure # =&gt; # Result: failure # RailwayFlow: # validate_divider -&gt; failure_message # Context: # :number =&gt; 4 # :divider =&gt; 0 # :error_message =&gt; \"Division by zero is not allowed\" # Status: NONE # Errors: # NONE . Railway flow . During execution Decouplio is recording executed steps, so you check which steps were executed. It becomes in handy during debugging and writing test. class RailwayAction &lt; Decouplio::Action logic do step :step1 step :step2 step :step3 end def step1 ctx[:step1] = 'Step1' end def step2 ctx[:step2] = 'Step2' end def step3 ctx[:step3] = 'Step3' end end railway_action = RailwayAction.call railway_action.railway_flow.inspect # =&gt; [:step1, :step2, :step3] railway_action # =&gt; # Result: success # RailwayFlow: # step1 -&gt; step2 -&gt; step3 # Context: # :step1 =&gt; \"Step1\" # :step2 =&gt; \"Step2\" # :step3 =&gt; \"Step3\" # Status: NONE # Errors: # NONE . Meta Store . Generally metastore is a PORO, which is accessible inside steps by calling meta_store method or itâ€™s alias ms. It was created to help developers to standardize things and keep meta info about action, because sometimes success? or failure? is not enough to make a decision about what to do next. I defined default metastore class which can manage custom action status and standardizes the way how error messages should be added. Thatâ€™s how default metastore class looks like . # frozen_string_literal: true module Decouplio class DefaultMetaStore attr_accessor :status, :errors def initialize @errors = {} @status = nil end def add_error(key, messages) @errors.store( key, (@errors[key] || []) + [messages].flatten ) end # This method is used to print metastore status to console # when you checking action output def to_s &lt;&lt;~METASTORE Status: #{@status || 'NONE'} Errors: #{errors_string} METASTORE end private def errors_string return 'NONE' if @errors.empty? @errors.map do |k, v| \"#{k.inspect} =&gt; #{v.inspect}\" end.join(\"\\n \") end end end . So itâ€™s allows you do this . class MetaStoreAction &lt; Decouplio::Action logic do step :always_fails fail :handle_fail end # Decouplio has to constants which are accessible inside steps # PASS = true # FAIL = false # You can use then to force step to fail or pass instead of `true` of `false` def always_fails FAIL end def handle_fail ms.status = :failed_and_i_duno_why ms.add_error(:something_went_wrong, 'Something went wrong') ms.add_error(:something_went_wrong, 'And I duno why :(') end end MetaStoreAction.call #=&gt; # Result: failure # RailwayFlow: # always_fails -&gt; handle_fail # Context: # Empty # Status: :failed_and_i_duno_why # Errors: # :something_went_wrong =&gt; [\"Something went wrong\", \"And I duno why :(\"] . NOTE: you can always define your own metastore class accordingly to your needs. DOCS ARE HERE . ",
    "url": "http://localhost:4000/decouplio.github.io/#what-should-you-know-before-start",
    "relUrl": "/#what-should-you-know-before-start"
  },"19": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/",
    "relUrl": "/"
  },"20": {
    "doc": "Inner action",
    "title": "Inner Action",
    "content": "step/fail/pass steps can perform another action instead of method. Context from parent action will be passed to inner action. Depending on inner action result(success|failure) next success or failure track step will be executed. NOTE: Be careful, as inner actions can override parent context. require 'decouplio' class InnerAction &lt; Decouplio::Action logic do step :step_one step :step_two end def step_one ctx # =&gt; ctx from parent action(SomeAction) ctx[:step_one] = 'Success' end def step_two ctx # =&gt; ctx from parent action(SomeAction) ctx[:step_two] = 'Success' end end class SomeAction &lt; Decouplio::Action logic do step InnerAction # OR # fail InnerAction # OR # pass InnerAction end end action = SomeAction.call action # =&gt; # Result: success # RailwayFlow: # InnerAction -&gt; step_one -&gt; step_two # Context: # :step_one =&gt; \"Success\" # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(any_name); subgraph inner action; 2(step_one)--&gt;|success track|3(step_two); end; 3(step_two)--&gt;|success track|4(finish success); The parent action context will be passed into inner action . ",
    "url": "http://localhost:4000/decouplio.github.io/inner_action/#inner-action",
    "relUrl": "/inner_action/#inner-action"
  },"21": {
    "doc": "Inner action",
    "title": "Options",
    "content": "All options for step/fail/pass can be applied for inner action step. ",
    "url": "http://localhost:4000/decouplio.github.io/inner_action/#options",
    "relUrl": "/inner_action/#options"
  },"22": {
    "doc": "Inner action",
    "title": "Inner action",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/inner_action/",
    "relUrl": "/inner_action/"
  },"23": {
    "doc": "Meta store",
    "title": "Meta store",
    "content": "Itâ€™s a simple PORO to persist meta data about action, like errors or some status or whatever you want, depends on your needs. By default each action uses Decouplio::DefaultMetaStore, but you can define your own. ",
    "url": "http://localhost:4000/decouplio.github.io/meta_store/",
    "relUrl": "/meta_store/"
  },"24": {
    "doc": "Meta store",
    "title": "Behavior",
    "content": ". | In case if inner action is used, then meta_store from parent action will be used inside inner action. | . ",
    "url": "http://localhost:4000/decouplio.github.io/meta_store/#behavior",
    "relUrl": "/meta_store/#behavior"
  },"25": {
    "doc": "Octo",
    "title": "Octo (experimental)",
    "content": "Itâ€™s a step type which helps to implement strategy pattern. ",
    "url": "http://localhost:4000/decouplio.github.io/octo/#octo-experimental",
    "relUrl": "/octo/#octo-experimental"
  },"26": {
    "doc": "Octo",
    "title": "Signature",
    "content": "octo(octo_name, (ctx_key:|method:), **step_options) do # Octo block on(octo_key, step_to_perform=nil, **step_options, &amp;block) end . ",
    "url": "http://localhost:4000/decouplio.github.io/octo/#signature",
    "relUrl": "/octo/#signature"
  },"27": {
    "doc": "Octo",
    "title": "Behavior",
    "content": ". | Octo executes different flows depending on specified value. | You have two options to set value for octo. By ctx_key and method. | ctx_key and method options are controversial, so you can use only one of them. | with ctx_key you can specify the key inside action context | with method you can specify method name symbol, which will be called to retrieve octo_key value. | step options from on definition will override options from octo step options | . ",
    "url": "http://localhost:4000/decouplio.github.io/octo/#behavior",
    "relUrl": "/octo/#behavior"
  },"28": {
    "doc": "Octo",
    "title": "Octo",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/octo/",
    "relUrl": "/octo/"
  },"29": {
    "doc": "on_error",
    "title": "on_error",
    "content": "Will be performed only in pair with resq step. When step raises an exception then specified on_error option will be performed, only after resq handler method execution. | Allowed values | Behavior | . | :PASS | performs next success track step | . | :FAIL | performs next failure track step | . | :finish_him | stops action execution | . | symbol of the next step | performs defined step, no matter on which track it is. | . # ... logic do step :step_one, on_error: :PASS # will perform step_two resq :handle_step_one step :step_two fail :fail_one end def step_one raise 'Something went wrong' end def handle_step_one(error) # handle an error end # ... # ... logic do step :step_one, on_error: :FAIL # will perform fail_one resq :handle_step_one step :step_two fail :fail_one end def step_one raise 'Something went wrong' end def handle_step_one(error) # handle an error end # ... # ... logic do step :step_one, on_error: :finish_him # will stop action execution resq :handle_step_one step :step_two fail :fail_one end def step_one raise 'Something went wrong' end def handle_step_one(error) # handle an error end # ... # ... logic do step :step_one, on_error: :fail_two # will perform fail_two resq :handle_step_one step :step_two fail :fail_one fail :fail_two end def step_one raise 'Something went wrong' end def handle_step_one(error) # handle an error end # ... ",
    "url": "http://localhost:4000/decouplio.github.io/on_error/",
    "relUrl": "/on_error/"
  },"30": {
    "doc": "on_failure",
    "title": "on_failure",
    "content": "If step result is falsy value then defined option value will be performed . | Allowed values | Behavior | . | :PASS | performs next success track step | . | :FAIL | performs next failure track step | . | :finish_him | stops action execution | . | symbol of the next step | performs defined step, no matter on which track it is. | . # ... logic do step :step_one, on_failure: :PASS # will perform step_two step :step_two fail :fail_one end def step_one false end # ... # ... logic do step :step_one, on_failure: :FAIL # will perform fail_one step :step_two fail :fail_one end def step_one false end # ... # ... logic do step :step_one, on_failure: :finish_him # will stop action execution step :step_two fail :fail_one end def step_one false end # ... # ... logic do step :step_one, on_failure: :fail_two # will perform fail_two step :step_two fail :fail_one fail :fail_two end def step_one false end # ... ",
    "url": "http://localhost:4000/decouplio.github.io/on_failure/",
    "relUrl": "/on_failure/"
  },"31": {
    "doc": "on_success",
    "title": "on_success",
    "content": "If step result is truthy value then defined option value will be performed . | Allowed values | Behavior | . | :PASS | performs next success track step | . | :FAIL | performs next failure track step | . | :finish_him | stops action execution | . | symbol of the next step | performs defined step, no matter on which track it is. | . # ... logic do step :step_one, on_success: :PASS # will perform step_two step :step_two fail :fail_one end def step_one true end # ... # ... logic do step :step_one, on_success: :FAIL # will perform fail_one step :step_two fail :fail_one end def step_one true end # ... # ... logic do step :step_one, on_success: :finish_him # will stop action execution step :step_two fail :fail_one end def step_one true end # ... # ... logic do step :step_one, on_success: :fail_two # will perform fail_two step :step_two fail :fail_one fail :fail_two end def step_one true end # ... ",
    "url": "http://localhost:4000/decouplio.github.io/on_success/",
    "relUrl": "/on_success/"
  },"32": {
    "doc": "Options",
    "title": "Octo options",
    "content": "| Option | Allowed | . | on_success | YES | . | on_failure | YES | . | on_error | YES | . | finish_him | NO | . | if | YES | . | unless | YES | . ",
    "url": "http://localhost:4000/decouplio.github.io/options/#octo-options",
    "relUrl": "/options/#octo-options"
  },"33": {
    "doc": "Options",
    "title": "Octo block options",
    "content": "Options which can be passed to on method for step . | Option | Allowed | . | on_success | YES | . | on_failure | YES | . | on_error | YES | . | finish_him | NO | . | if | NO | . | unless | NO | . NOTE: on method options take precedence over octo step options. class OctoOptions &lt; Decouplio::Action logic do octo :octo_name, ctx_key: :octo_key, on_success: :FAIL, on_failure: :PASS, on_error: :PASS, if: :something do on :octo_key1, :step_one, on_success: :PASS, on_failure: :FAIL, on_error: :PASS on :octo_key2, :step_two, on_success: :finish_him, on_failure: :finish_him, on_error: :finish_him on :octo_key3, on_success: :step_two, on_error: :finish_him do step :step_one end end end def step_one ctx[:step_one] = 'Success' end def step_two ctx[:step_two] = 'Success' end end . ",
    "url": "http://localhost:4000/decouplio.github.io/options/#octo-block-options",
    "relUrl": "/options/#octo-block-options"
  },"34": {
    "doc": "Options",
    "title": "Options",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/options/",
    "relUrl": "/options/"
  },"35": {
    "doc": "Pass",
    "title": "Pass",
    "content": "pass is the step type that always moves to success track logic steps . ",
    "url": "http://localhost:4000/decouplio.github.io/pass/",
    "relUrl": "/pass/"
  },"36": {
    "doc": "Pass",
    "title": "Signature",
    "content": "pass(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/pass/#signature",
    "relUrl": "/pass/#signature"
  },"37": {
    "doc": "Pass",
    "title": "Behavior",
    "content": ". | when step method(#pass_one) returns truthy or falsy value then it goes to success track(step_two step) | . require 'decouplio' class SomeAction &lt; Decouplio::Action logic do pass :pass_one step :step_two fail :fail_one end def pass_one ctx[:pass_one] = c.param_for_pass end def step_two ctx[:step_two] = 'Success' end def fail_one ctx[:fail_one] = 'Failure' end end pass_success = SomeAction.call(param_for_pass: true) pass_failure = SomeAction.call(param_for_pass: false) pass_success # =&gt; # Result: success # RailwayFlow: # pass_one -&gt; step_two # Context: # :param_for_pass =&gt; true # :pass_one =&gt; true # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE pass_failure # =&gt; # Result: success # RailwayFlow: # pass_one -&gt; step_two # Context: # :param_for_pass =&gt; false # :pass_one =&gt; false # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(pass_one success); 1(start)--&gt;3(pass_one failure); 2(pass_one success)--&gt;|success track|4(step_two); 3(pass_one failure)--&gt;|success track|4(step_two); 4(step_two)--&gt;|success track|5(finish_success) . ",
    "url": "http://localhost:4000/decouplio.github.io/pass/#behavior",
    "relUrl": "/pass/#behavior"
  },"38": {
    "doc": "Quick start",
    "title": "How to install?",
    "content": "gem install decouplio --pre . Gemfile . gem 'decouplio', '~&gt; 1.0.0rc' . ",
    "url": "http://localhost:4000/decouplio.github.io/quick_start/#how-to-install",
    "relUrl": "/quick_start/#how-to-install"
  },"39": {
    "doc": "Quick start",
    "title": "Quick start",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/quick_start/",
    "relUrl": "/quick_start/"
  },"40": {
    "doc": "Quick start",
    "title": "What should you know before start?",
    "content": "Action . Action is a class which encapsulates business logic. To create one just create a class and inherit it from Decouplio::Action class . require 'decouplio' class MyAction &lt; Decouplio::Action end . Logic block . Block inside Action which contains definition of business logic. require 'decouplio' class MyAction &lt; Decouplio::Action logic do # logic block end end . Step . Step is an atomic part of business logic and it defines inside Logic block. require 'decouplio' class MyAction &lt; Decouplio::Action logic do step :hello_world end def hello_world ctx[:result] = 'Hello world' end end MyAction.call[:result] # =&gt; Hello world . | Step types | . | step | . | fail | . | pass | . | wrap | . | octo | . | resq | . Context . Action context is an object which is used to share data between steps. Itâ€™s accessible only inside step. | To access the action context inside step you need to call ctx method | ctx behaves like a Hash. | To assign some value to ctx just do ctx[:some_key] = 'some value' | To access ctx value use ctx[:some_value] or use a shortcut c.some_value | . NOTE: you canâ€™t assign context value using c.&lt;some key&gt; shortcut. require 'decouplio' class CtxIntroduction &lt; Decouplio::Action logic do step :calculate_result end def calculate_result ctx[:result] = c.one + c.two # OR # c[:result] = c[:one] + c[:two] #OR # ctx[:result] = ctx[:one] + ctx[:two] end end action_result = CtxIntroduction.call(one: 1, two: 2) action_result[:result] # =&gt; 3 . Success/Failure track . Execution flow of action is changing depending on step result. | If step returns truthy value(not nil|false), when next success track step will be executed. | If step returns falsy value(nil|false), when next failure track step will be executed. | . | Success track | Failure track | . | step | fail | . | pass | Â  | . | wrap | Â  | . | octo | Â  | . require 'decouplio' class Divider &lt; Decouplio::Action logic do step :validate_divider step :divide fail :failure_message end def validate_divider !ctx[:divider].zero? end def divide ctx[:result] = c.number / c.divider end def failure_message ctx[:error_message] = 'Division by zero is not allowed' end end divider_success = Divider.call(number: 4, divider: 2) divider_success.success? # =&gt; true divider_success.failure? # =&gt; false divider_success[:result] # =&gt; 2 divider_success[:error_message] # =&gt; nil divider_success.railway_flow # =&gt; [:validate_divider, :divide] puts divider_success # =&gt; # Result: success # RailwayFlow: # validate_divider -&gt; divide # Context: # :number =&gt; 4 # :divider =&gt; 2 # :result =&gt; 2 # Status: NONE # Errors: # NONE divider_failure = Divider.call(number: 4, divider: 0) divider_failure.success? #=&gt; false divider_failure.failure? #=&gt; true divider_failure[:result] # =&gt; nil divider_failure[:error_message] # =&gt; 'Division by zero is not allowed' divider_failure.railway_flow# =&gt; [:validate_divider, :failure_message] divider_failure # =&gt; # Result: failure # RailwayFlow: # validate_divider -&gt; failure_message # Context: # :number =&gt; 4 # :divider =&gt; 0 # :error_message =&gt; \"Division by zero is not allowed\" # Status: NONE # Errors: # NONE . Railway flow . During execution Decouplio is recording executed steps, so you check which steps were executed. It becomes in handy during debugging and writing test. class RailwayAction &lt; Decouplio::Action logic do step :step1 step :step2 step :step3 end def step1 ctx[:step1] = 'Step1' end def step2 ctx[:step2] = 'Step2' end def step3 ctx[:step3] = 'Step3' end end railway_action = RailwayAction.call railway_action.railway_flow.inspect # =&gt; [:step1, :step2, :step3] railway_action # =&gt; # Result: success # RailwayFlow: # step1 -&gt; step2 -&gt; step3 # Context: # :step1 =&gt; \"Step1\" # :step2 =&gt; \"Step2\" # :step3 =&gt; \"Step3\" # Status: NONE # Errors: # NONE . Meta Store . Generally metastore is a PORO, which is accessible inside steps by calling meta_store method or itâ€™s alias ms. It was created to help developers to standardize things and keep meta info about action, because sometimes success? or failure? is not enough to make a decision about what to do next. I defined default metastore class which can manage custom action status and standardizes the way how error messages should be added. Thatâ€™s how default metastore class looks like . # frozen_string_literal: true module Decouplio class DefaultMetaStore attr_accessor :status, :errors def initialize @errors = {} @status = nil end def add_error(key, messages) @errors.store( key, (@errors[key] || []) + [messages].flatten ) end # This method is used to print metastore status to console # when you checking action output def to_s &lt;&lt;~METASTORE Status: #{@status || 'NONE'} Errors: #{errors_string} METASTORE end private def errors_string return 'NONE' if @errors.empty? @errors.map do |k, v| \"#{k.inspect} =&gt; #{v.inspect}\" end.join(\"\\n \") end end end . So itâ€™s allows you do this . class MetaStoreAction &lt; Decouplio::Action logic do step :always_fails fail :handle_fail end # Decouplio has tWo constants which are accessible inside steps # PASS = true # FAIL = false # You can use then to force step to fail or pass instead of `true` of `false` def always_fails FAIL end def handle_fail ms.status = :failed_and_i_duno_why ms.add_error(:something_went_wrong, 'Something went wrong') ms.add_error(:something_went_wrong, 'And I duno why :(') end end MetaStoreAction.call #=&gt; # Result: failure # RailwayFlow: # always_fails -&gt; handle_fail # Context: # Empty # Status: :failed_and_i_duno_why # Errors: # :something_went_wrong =&gt; [\"Something went wrong\", \"And I duno why :(\"] . NOTE: you can always define your own metastore class accordingly to your needs. DOCS ARE HERE . ",
    "url": "http://localhost:4000/decouplio.github.io/quick_start/#what-should-you-know-before-start",
    "relUrl": "/quick_start/#what-should-you-know-before-start"
  },"41": {
    "doc": "Resq",
    "title": "Resq",
    "content": "Step type which can be used to handle errors raised during step invocation. ",
    "url": "http://localhost:4000/decouplio.github.io/resq/",
    "relUrl": "/resq/"
  },"42": {
    "doc": "Resq",
    "title": "Signature",
    "content": "resq(handler_method=nil, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/resq/#signature",
    "relUrl": "/resq/#signature"
  },"43": {
    "doc": "Resq",
    "title": "Behavior",
    "content": ". | When resq step is defined it will catch exceptions raised from step defined above. | After resq performed handler method, next failure track step will be performed. You can override this behavior using on_error option for step. *** | . ",
    "url": "http://localhost:4000/decouplio.github.io/resq/#behavior",
    "relUrl": "/resq/#behavior"
  },"44": {
    "doc": "Resq all",
    "title": "Resq all",
    "content": "To catch any exception(inherited from StandardError) by resq you just need to specify a handler method, like in the example below. require 'decouplio' class ResqAllAction &lt; Decouplio::Action logic do step :step_one resq :handler_method step :step_two fail :fail_one end def step_one ctx[:step_one] = c.lambda_for_step_one.call end def step_two ctx[:step_two] = 'Success' end def fail_one ctx[:fail_one] = 'Failure' end def handler_method(error) ctx[:error] = error.message end end success_action = ResqAllAction.call(lambda_for_step_one: -&gt; { true }) failure_action = ResqAllAction.call(lambda_for_step_one: -&gt; { false }) erroneous_action = ResqAllAction.call( lambda_for_step_one: -&gt; { raise 'some error message' } ) success_action # =&gt; # Result: success # RailwayFlow: # step_one -&gt; step_two # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055b2f3d57ea0 resq/resq_all.rb:28 (lambda)&gt; # :step_one =&gt; true # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE failure_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055b2f3d57c98 resq/resq_all.rb:29 (lambda)&gt; # :step_one =&gt; false # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE erroneous_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; handler_method -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055b2f3d56d70 resq/resq_all.rb:31 (lambda)&gt; # :error =&gt; \"some error message\" # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|failure track|6(finish failure); 2(step_one)--&gt;|error track|7(handler_method); 7(handler_method)--&gt;|error track|5(fail_one); ",
    "url": "http://localhost:4000/decouplio.github.io/rescue_all/",
    "relUrl": "/rescue_all/"
  },"45": {
    "doc": "Resq with mapping",
    "title": "Resq with error class mapping",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/rescue_with_mapping/#resq-with-error-class-mapping",
    "relUrl": "/rescue_with_mapping/#resq-with-error-class-mapping"
  },"46": {
    "doc": "Resq with mapping",
    "title": "With one handler method and class",
    "content": "require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one resq handler_method: ArgumentError step :step_two fail :fail_one end def step_one(lambda_for_step_one:, **) ctx[:step_one] = lambda_for_step_one.call end def step_two(**) ctx[:step_two] = 'Success' end def fail_one(**) ctx[:fail_one] = 'Failure' end def handler_method(error, **this_is_ctx) ctx[:error] = error.message end end success_action = SomeAction.call(lambda_for_step_one: -&gt; { true }) failure_action = SomeAction.call(lambda_for_step_one: -&gt; { false }) erroneous_action = SomeAction.call( lambda_for_step_one: -&gt; { raise ArgumentError, 'some error message' } ) success_action # =&gt; # Result: success # RailwayFlow: # step_one -&gt; step_two # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055cd61ed4318 resq.rb:32 (lambda)&gt; # :step_one =&gt; true # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE failure_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055cd61eccac8 resq.rb:33 (lambda)&gt; # :step_one =&gt; false # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE erroneous_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; handler_method -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055cd61ebf5d0 resq.rb:35 (lambda)&gt; # :error =&gt; \"some error message\" # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|failure track|6(finish failure); 2(step_one)--&gt;|error track|7(handler_method); 7(handler_method)--&gt;|error track|5(fail_one); ",
    "url": "http://localhost:4000/decouplio.github.io/rescue_with_mapping/#with-one-handler-method-and-class",
    "relUrl": "/rescue_with_mapping/#with-one-handler-method-and-class"
  },"47": {
    "doc": "Resq with mapping",
    "title": "With several handler methods and classes",
    "content": "class SomeActionSeveralHandlersErrorClasses &lt; Decouplio::Action logic do step :step_one resq handler_method_one: [ArgumentError, NoMethodError], handler_method_two: NotImplementedError step :step_two fail :fail_one end def step_one ctx[:step_one] = c.lambda_for_step_one.call end def step_two ctx[:step_two] = 'Success' end def fail_one ctx[:fail_one] = 'Failure' end def handler_method_one(error) ctx[:error] = error.message end def handler_method_two(error) ctx[:error] = error.message end end success_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { true } ) failure_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { false } ) argument_error_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { raise ArgumentError, 'Argument error message' } ) no_method_error_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { raise NoMethodError, 'NoMethodError error message' } ) no_implemented_error_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { raise NotImplementedError, 'NotImplementedError error message' } ) success_action # =&gt; # Result: success # RailwayFlow: # step_one -&gt; step_two # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055e5d6d61d68 resq/resq_with_mapping.rb:102 (lambda)&gt; # :step_one =&gt; true # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE failure_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055e5d6d61c00 resq/resq_with_mapping.rb:105 (lambda)&gt; # :step_one =&gt; false # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE argument_error_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; handler_method_one -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055e5d6d61a98 resq/resq_with_mapping.rb:108 (lambda)&gt; # :error =&gt; \"Argument error message\" # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE no_method_error_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; handler_method_one -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055e5d6d61868 resq/resq_with_mapping.rb:111 (lambda)&gt; # :error =&gt; \"NoMethodError error message\" # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE no_implemented_error_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; handler_method_two -&gt; fail_one # Context: # :lambda_for_step_one =&gt; #&lt;Proc:0x000055e5d6d614a8 resq/resq_with_mapping.rb:114 (lambda)&gt; # :error =&gt; \"NotImplementedError error message\" # :fail_one =&gt; \"Failure\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|failure track|6(finish failure); 2(step_one)--&gt;|ArgumentError|7(handler_method_one); 2(step_one)--&gt;|NoMethodError|9(handler_method_one); 2(step_one)--&gt;|NotImplementedError|8(handler_method_two); 7(handler_method_one)--&gt;|error track|5(fail_one); 9(handler_method_one)--&gt;|error track|5(fail_one); 8(handler_method_two)--&gt;|error track|5(fail_one); ",
    "url": "http://localhost:4000/decouplio.github.io/rescue_with_mapping/#with-several-handler-methods-and-classes",
    "relUrl": "/rescue_with_mapping/#with-several-handler-methods-and-classes"
  },"48": {
    "doc": "Resq with mapping",
    "title": "Resq with mapping",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/rescue_with_mapping/",
    "relUrl": "/rescue_with_mapping/"
  },"49": {
    "doc": "Simple wrap",
    "title": "Simple wrap",
    "content": "class SomeAction &lt; Decouplio::Action logic do step :step_one wrap :wrap_one do step :step_two fail :fail_one end step :step_three fail :fail_two end def step_one(param_for_step_one:, **) ctx[:step_one] = param_for_step_one end def step_two(param_for_step_two:, **) ctx[:step_two]= param_for_step_two end def fail_one(**) ctx[:fail_one] = 'Fail one failure' end def step_three(**) ctx[:step_three] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Fail two failure' end end success_wrap_success = SomeAction.call( param_for_step_one: true, param_for_step_two: true ) success_wrap_failure = SomeAction.call( param_for_step_one: true, param_for_step_two: false ) failure = SomeAction.call( param_for_step_one: false ) success_wrap_success # =&gt; # Result: success # RailwayFlow: # step_one -&gt; wrap_one -&gt; step_two -&gt; step_three # Context: # :param_for_step_one =&gt; true # :param_for_step_two =&gt; true # :step_one =&gt; true # :step_two =&gt; true # :step_three =&gt; \"Success\" # Status: NONE # Errors: # NONE success_wrap_failure # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; wrap_one -&gt; step_two -&gt; fail_one -&gt; fail_two # Context: # :param_for_step_one =&gt; true # :param_for_step_two =&gt; false # :step_one =&gt; true # :step_two =&gt; false # :fail_one =&gt; \"Fail one failure\" # :fail_two =&gt; \"Fail two failure\" # Status: NONE # Errors: # NONE failure # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; fail_two # Context: # :param_for_step_one =&gt; false # :step_one =&gt; false # :fail_two =&gt; \"Fail two failure\" # Status: NONE # Errors: # NONE . flowchart TD; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(wrap_one); subgraph wrap action; 3(wrap_one)--&gt;|success track|4(start); 4(start)--&gt;5(step_two); 5(step_two)--&gt;|success track|6(finish success); 5(step_two)--&gt;|failure track|9(fail_one); 9(fail_one)--&gt;|failure track|10(finish failure); end; 6(finish success)--&gt;|success track|7(step_three); 7(step_three)--&gt;|success track|8(finish success); 10(finish failure)--&gt;|failure track|11(fail_two); 11(fail_two)--&gt;|failure track|12(finish failure); 2(step_one)--&gt;|failure track|11(fail_two) ",
    "url": "http://localhost:4000/decouplio.github.io/simple_wrap/",
    "relUrl": "/simple_wrap/"
  },"50": {
    "doc": "Special constants",
    "title": "Special constants",
    "content": "Decouplio has two special constants PASS and FAIL. They simply are . PASS = true FAIL = false . You can use them inside step method as last line to make step pass of fail. class SomeAction &lt; Decouplio::Action logic do step :step_one end def step_one FAIL end end SomeAction.call #=&gt; # Result: failure # RailwayFlow: # step_one # Context: # Empty # Status: NONE # Errors: # NONE . ",
    "url": "http://localhost:4000/decouplio.github.io/special%20constants/",
    "relUrl": "/special constants/"
  },"51": {
    "doc": "Step",
    "title": "Step",
    "content": "step is the basic type of logic steps . ",
    "url": "http://localhost:4000/decouplio.github.io/step/",
    "relUrl": "/step/"
  },"52": {
    "doc": "Step",
    "title": "Signature",
    "content": "step(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/step/#signature",
    "relUrl": "/step/#signature"
  },"53": {
    "doc": "Step",
    "title": "Behavior",
    "content": ". | when step method(#step_one) returns truthy value then it goes to success track(step_two step) | when step method(#step_one) returns falsy value then it goes to failure track(fail_one step) | . require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two end def step_one c.param_for_step_one end def fail_one ctx[:action_failed] = true end def step_two ctx[:result] = 'Success' end end success_action = SomeAction.call(param_for_step_one: true) failure_action = SomeAction.call(param_for_step_one: false) success_action # =&gt; # Result: success # RailwayFlow: # step_one -&gt; step_two # Context: # :param_for_step_one =&gt; true # :result =&gt; \"Success\" # Status: NONE # Errors: # NONE failure_action # =&gt; # Result: failure # RailwayFlow: # step_one -&gt; fail_one # Context: # :param_for_step_one =&gt; false # :action_failed =&gt; true # Status: NONE # Errors: # NONE . flowchart LR; A(start)--&gt;B(step_one); B(step_one)--&gt;|success track|C(step_two); B(step_one)--&gt;|failure track|D(fail_one); C(step_two)--&gt;|success track|E(finish_success); D(fail_one)--&gt;|failure track|F(finish_failure); . ",
    "url": "http://localhost:4000/decouplio.github.io/step/#behavior",
    "relUrl": "/step/#behavior"
  },"54": {
    "doc": "Step as a service",
    "title": "Step as a service",
    "content": "Itâ€™s similar to Inner action, but instead of using Decouplio::Action, you can use PORO class. ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/",
    "relUrl": "/step_as_a_service/"
  },"55": {
    "doc": "Step as a service",
    "title": "Signature",
    "content": "(step|fail|pass)(service_class, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/#signature",
    "relUrl": "/step_as_a_service/#signature"
  },"56": {
    "doc": "Step as a service",
    "title": "Behavior",
    "content": ". | service class should implement .call class method | service class can be used for step or fail or pass | all options of step|fail|pass can be used, the same approach as for Inner action | depending on returning value of .call method(truthy ot falsy) the execution will be moved to success or failure track accordingly. | All options passed after class constant will be passed as kwargs into .call method, except default step/fail/pass options like on_success, on_failure, on_error, finish_him, if, unless | . ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/#behavior",
    "relUrl": "/step_as_a_service/#behavior"
  },"57": {
    "doc": "Step as a service",
    "title": "How to use?",
    "content": "Create a PORO class with .call class method. # ctx - required, it's a ctx from Decouplio::Action # ms - required, it's an meta_store from Decouplio::Action class Concat def self.call(ctx, ms, **) new(ctx).call end def initialize(ctx) @ctx = ctx end def call @ctx[:result] = @ctx[:one] + @ctx[:two] end end # OR # ctx - required, it's a ctx from Decouplio::Action # ms - required, it's an meta_store from Decouplio::Action class Subtract def self.call(ctx, ms, **) ctx[:result] = ctx[:one] - ctx[:two] end end # OR # :ctx - it's a ctx from Decouplio::Action # :ms - it's an meta_store from Decouplio::Action class MakeRequest def self.call(ctx, ms, **) ctx[:client].get(ctx[:url]) rescue Net::OpenTimeout =&gt; error ms.status = :timeout_error ms.add_error(:connection_error, error.message) end end . Now you can use these classes as a step|fail|pass step . class SomeActionConcat &lt; Decouplio::Action logic do step Concat end end action = SomeActionConcat.call(one: 1, two: 2) action[:result] # =&gt; 3 action # =&gt; # Result: success # RailwayFlow: # Concat # Context: # :one =&gt; 1 # :two =&gt; 2 # :result =&gt; 3 # Status: NONE # Errors: # NONE . OR . class SomeActionSubtract &lt; Decouplio::Action logic do step :init_one step :init_two step Subtract end def init_one ctx[:one] = c.param_one end def init_two ctx[:two] = c.param_two end end action = SomeActionSubtract.call(param_one: 5, param_two: 2) action[:result] # =&gt; 3 action # =&gt; # Result: success # RailwayFlow: # init_one -&gt; init_two -&gt; Subtract # Context: # :param_one =&gt; 5 # :param_two =&gt; 2 # :one =&gt; 5 # :two =&gt; 2 # :result =&gt; 3 # Status: NONE # Errors: # NONE . ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/#how-to-use",
    "relUrl": "/step_as_a_service/#how-to-use"
  },"58": {
    "doc": "Step options",
    "title": "Step options",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/step_options/",
    "relUrl": "/step_options/"
  },"59": {
    "doc": "With inner action",
    "title": "With inner action",
    "content": "Octo with inner action . class InnerActionOne &lt; Decouplio::Action logic do step :inner_step_one end def inner_step_one ctx[:inner_step_one] = 'Inner step one' end end class InnerActionTwo &lt; Decouplio::Action logic do step :inner_step_two end def inner_step_two ctx[:inner_step_two] = 'Inner step two' end end class OctoAsInnerAction &lt; Decouplio::Action logic do octo :octo_name, ctx_key: :octo_key do on :octo_key1, InnerActionOne on :octo_key2, InnerActionTwo end end end OctoAsInnerAction.call(octo_key: :octo_key1) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key1 -&gt; InnerActionOne -&gt; inner_step_one # Context: # :octo_key =&gt; :octo_key1 # :inner_step_one =&gt; \"Inner step one\" # Status: NONE # Errors: # NONE OctoAsInnerAction.call(octo_key: :octo_key2) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key2 -&gt; InnerActionTwo -&gt; inner_step_two # Context: # :octo_key =&gt; :octo_key2 # :inner_step_two =&gt; \"Inner step two\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(octo_name); 2(octo_name)--&gt;|when :octo_key1|4(inner_step_one); 2(octo_name)--&gt;|when :octo_key2|6(inner_step_two); subgraph InnerActionOne; 4(inner_step_one)--&gt;7(finish_success); end; subgraph InnerActionTwo; 6(inner_step_two)--&gt;8(finish_success); end; 7(finish_success)--&gt;9(finish_success); 8(finish_success)--&gt;9(finish_success); ",
    "url": "http://localhost:4000/decouplio.github.io/octo_as_inner_action/",
    "relUrl": "/octo_as_inner_action/"
  },"60": {
    "doc": "With service step",
    "title": "With service step",
    "content": "Octo with service step . class AssignMessage def self.call(ctx, ms, message:) ctx[:message] = message end end class OctoServiceStep &lt; Decouplio::Action logic do octo :octo_name, ctx_key: :octo_key do on :octo_key1, AssignMessage, message: 'Octo key 1', on_success: :PASS on :octo_key2, AssignMessage, message: 'Octo key 2', on_success: :PASS end end end puts OctoServiceStep.call(octo_key: :octo_key1) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key1 -&gt; AssignMessage # Context: # :octo_key =&gt; :octo_key1 # :message =&gt; \"Octo key 1\" # Status: NONE # Errors: # NONE puts OctoServiceStep.call(octo_key: :octo_key2) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key2 -&gt; AssignMessage # Context: # :octo_key =&gt; :octo_key2 # :message =&gt; \"Octo key 2\" # Status: NONE # Errors: # NONE . ",
    "url": "http://localhost:4000/decouplio.github.io/octo_as_service_step/",
    "relUrl": "/octo_as_service_step/"
  },"61": {
    "doc": "With steps",
    "title": "With steps",
    "content": "You can specify a single step or several steps for octo case . logic do octo :octo_name, ctx_key: :octo_key do on :octo_key1, :step_one # Several steps could be also defined # such block will behave like simple 'warp' step on :octo_key2 do step :step_two step :step_one end end end def step_one ctx[:step_one] = 'step_one success' end def step_two ctx[:step_two] = 'step_two success' end end OctoAsStep.call(octo_key: :octo_key1) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key1 -&gt; step_one # Context: # :octo_key =&gt; :octo_key1 # :step_one =&gt; \"step_one success\" # Status: NONE # Errors: # NONE OctoAsStep.call(octo_key: :octo_key2) # =&gt; # Result: success # RailwayFlow: # octo_name -&gt; octo_key2 -&gt; step_two -&gt; step_one # Context: # :octo_key =&gt; :octo_key2 # :step_two =&gt; \"step_two success\" # :step_one =&gt; \"step_one success\" # Status: NONE # Errors: # NONE . flowchart LR; A(start)--&gt;B(octo_name); B(octo_name)--&gt;|when :octo_key1|C(step_one); B(octo_name)--&gt;|when :octo_key2|D(step_two); C(step_one)--&gt;|success track|E(finish_success); D(step_two)--&gt;|success track|F(step_one); F(step_one)--&gt;|success track|E(finish_success); ",
    "url": "http://localhost:4000/decouplio.github.io/octo_as_steps/",
    "relUrl": "/octo_as_steps/"
  },"62": {
    "doc": "Wrap",
    "title": "Wrap",
    "content": "wrap is the type of step, that behaves like step, but can wrap several steps with block to make some before/after actions or to rescue an error for several steps. ",
    "url": "http://localhost:4000/decouplio.github.io/wrap/",
    "relUrl": "/wrap/"
  },"63": {
    "doc": "Wrap",
    "title": "Signature",
    "content": "wrap(wrap_name, **options) do # steps to wrap end . ",
    "url": "http://localhost:4000/decouplio.github.io/wrap/#signature",
    "relUrl": "/wrap/#signature"
  },"64": {
    "doc": "Wrap",
    "title": "Behavior",
    "content": ". | all steps inside wrap step will be perceived as inner action. So depending on inner action result the wrap step will be moved to success or failure track. | All step options for step can be applied for wrap | . ",
    "url": "http://localhost:4000/decouplio.github.io/wrap/#behavior",
    "relUrl": "/wrap/#behavior"
  },"65": {
    "doc": "With class",
    "title": "Wrap with class",
    "content": "require 'decouplio' class WrapperClass def self.call(&amp;block) if block_given? puts 'Before wrapper action execution' block.call puts 'After wrapper action execution' end end end class SomeActionWrapKlassMethod &lt; Decouplio::Action logic do wrap :wrap_one, klass: WrapperClass do step :step_one step :step_two end end def step_one puts 'Step one' ctx[:step_one] = 'Success' end def step_two puts 'Step two' ctx[:step_two] = 'Success' end end action = SomeActionWrapKlassMethod.call # =&gt; # Before wrapper action execution # Step one # Step two # After wrapper action execution action # =&gt; # Result: success # RailwayFlow: # wrap_one -&gt; step_one -&gt; step_two # Context: # :step_one =&gt; \"Success\" # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE . ",
    "url": "http://localhost:4000/decouplio.github.io/with_class/#wrap-with-class",
    "relUrl": "/with_class/#wrap-with-class"
  },"66": {
    "doc": "With class",
    "title": "With class",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/with_class/",
    "relUrl": "/with_class/"
  },"67": {
    "doc": "With class and method",
    "title": "Wrap with class and method",
    "content": "require 'decouplio' class WrapperClass def self.some_wrapper_method(&amp;block) if block_given? puts 'Before wrapper action execution' block.call puts 'After wrapper action execution' end end end class SomeActionWrapKlassMethod &lt; Decouplio::Action logic do wrap :wrap_one, klass: WrapperClass, method: :some_wrapper_method do step :step_one step :step_two end end def step_one(**) puts 'Step one' ctx[:step_one] = 'Success' end def step_two(**) puts 'Step two' ctx[:step_two] = 'Success' end end action = SomeActionWrapKlassMethod.call # =&gt; # Before wrapper action execution # Step one # Step two # After wrapper action execution action # =&gt; # Result: success # RailwayFlow: # wrap_one -&gt; step_one -&gt; step_two # Context: # :step_one =&gt; \"Success\" # :step_two =&gt; \"Success\" # Status: NONE # Errors: # NONE . flowchart LR; 1(start)--&gt;2(wrap_one); subgraph wrap action; 2(wrap_one)--&gt;|success track|3(step_one); 3(step_one)--&gt;|success track|4(step_two); 4(step_two)--&gt;|success track|5(finish success); end; 5(finish success)--&gt;|success track|6(finish success) ",
    "url": "http://localhost:4000/decouplio.github.io/with_class_method/#wrap-with-class-and-method",
    "relUrl": "/with_class_method/#wrap-with-class-and-method"
  },"68": {
    "doc": "With class and method",
    "title": "With class and method",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/with_class_method/",
    "relUrl": "/with_class_method/"
  }
}
