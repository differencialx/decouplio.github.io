{"0": {
    "doc": "Context",
    "title": "Context",
    "content": "Currently context is a simple Hash which can be accessed by step methods. require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one step :step_two end def step_one(**) ctx[:step_one] = 'Step one ctx value' end # step method receives ctx as an argument def step_two(step_one:, **) ctx[:step_two] = step_one end end action = SomeAction.call action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:step_one=&gt;\"Step one ctx value\", :step_two=&gt;\"Step one ctx value\"} # Errors: # {} . All key values passed into call method will be automatically assigned to action context. require 'decouplio' class SomeActionCtx &lt; Decouplio::Action logic do step :step_one end def step_one(**) puts ctx ctx[:result] = ctx[:one] + ctx[:two] end end action = SomeActionCtx.call( one: 1, two: 2 ) # =&gt; # {:one=&gt;1, :two=&gt;2} action[:result] # =&gt; 3 action # =&gt; # Result: success # Railway Flow: # step_one # Context: # {:one=&gt;1, :two=&gt;2, :result=&gt;3} # Errors: # {} . ",
    "url": "http://localhost:4000/decouplio.github.io/context/",
    "relUrl": "/context/"
  },"1": {
    "doc": "Doby/Aide",
    "title": "Doby/Aide",
    "content": "Steps which make configurable manipulations with action context. ",
    "url": "http://localhost:4000/decouplio.github.io/doby_aide/",
    "relUrl": "/doby_aide/"
  },"2": {
    "doc": "Doby/Aide",
    "title": "Signature",
    "content": "doby(class_constant, **options) aide(class_constant, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/doby_aide/#signature",
    "relUrl": "/doby_aide/#signature"
  },"3": {
    "doc": "Doby/Aide",
    "title": "Behavior",
    "content": "Doby . | doby behaves similar to step, depending on .call method returning value(truthy or falsy) the execution will be moved to success or failure track accordingly. | doby doesn’t have on_success, on_failure, if, unless, finish_him options. | All options passed after class constant will be passed as kwargs for .call method. | . Aide . | aide behaves similar to fail, no matter which value will be returned by .call method, it moves to failure track. | aide doesn’t have on_success, on_failure, if, unless, finish_him options. | All options passed after class constant will be passed as kwargs for .call method. | . ",
    "url": "http://localhost:4000/decouplio.github.io/doby_aide/#behavior",
    "relUrl": "/doby_aide/#behavior"
  },"4": {
    "doc": "Doby/Aide",
    "title": "How to use?",
    "content": "Create the ruby class which has .call class method.call method signature: . # :ctx - it's a ctx from Decouplio::Action # :error_store - it's an error_store from Decouplio::Action # you can call #add_error method on it. # ** - kwargs passed from action. def self.call(ctx:, error_store:, **) end . class AssignDoby def self.call(ctx:, to:, from: nil, value: nil, **) raise 'from/value is empty' unless from || value ctx[to] = value || ctx[from] end end # OR class SemanticAide def self.call(ctx:, error_store:, semantic:, error_message:) ctx[:semantic] = semantic error_store.add_error(semantic, error_message) end end # OR # If you don't need ctx and error_store, you can omit them class DummyDoby def self.call(dummy:, **) puts dummy end end . AssignDoby example. require 'decouplio' class AssignDoby def self.call(ctx:, to:, from: nil, value: nil, **) raise 'from/value is empty' unless from || value ctx[to] = value || ctx[from] end end class SomeAction &lt; Decouplio::Action logic do step :user doby AssignDoby, to: :current_user, from: :user end def user(id:, **) ctx[:user] = \"User with id: #{id}\" end end action = SomeAction.call(id: 1) action[:user] # =&gt; \"User with id: 1\" action[:current_user] # =&gt; \"User with id: 1\" action # =&gt; # Result: success # Railway Flow: # user -&gt; AssignDoby # Context: # {:id=&gt;1, :user=&gt;\"User with id: 1\", :current_user=&gt;\"User with id: 1\"} # Errors: # {} . SemanticAide example. require 'decouplio' class SemanticAide def self.call(ctx:, error_store:, semantic:, error_message:) ctx[:semantic] = semantic error_store.add_error(semantic, error_message) end end class SomeAction &lt; Decouplio::Action logic do step :step_one aide SemanticAide, semantic: :bad_request, error_message: 'Bad request' step :step_two end def step_one(step_one_param:, **) ctx[:step_one] = step_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_one(**) ctx[:fail_one] = 'Failure' end end success_action = SomeAction.call(step_one_param: true) failure_action = SomeAction.call(step_one_param: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # :step_one_param =&gt; true # :step_one =&gt; true # :step_two =&gt; \"Success\" # Errors: # None failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; SemanticAide # Context: # :step_one_param =&gt; false # :step_one =&gt; false # :semantic =&gt; :bad_request # Errors: # :bad_request =&gt; [\"Bad request\"] . ",
    "url": "http://localhost:4000/decouplio.github.io/doby_aide/#how-to-use",
    "relUrl": "/doby_aide/#how-to-use"
  },"5": {
    "doc": "Doby/Aide",
    "title": "Options",
    "content": "Doby . Has the same options and behavior as step, just specify them along with doby class options like here: . # ... logic do doby AssignDoby, to: :current_user, from: :user, on_success: :finish_him, if: :condition end # ... Aide . Has the same options and behavior as fail, just specify them along with aide class options like here: . # ... logic do step :step_one aide SemanticAide, semantic: :bad_request, error_message: 'Bad request', on_failure: :PASS, unless: :condition end # ... ",
    "url": "http://localhost:4000/decouplio.github.io/doby_aide/#options",
    "relUrl": "/doby_aide/#options"
  },"6": {
    "doc": "Error store",
    "title": "Error store",
    "content": "It’s an object to store errors. By default Decouplio::DefaultErrorHandler is used for Decouplio::Action . module Decouplio class DefaultErrorHandler attr_reader :errors def initialize @errors = {} end def add_error(key, message) @errors.store( key, (@errors[key] || []) + [message].flatten ) end def merge(error_store) @errors = @errors.merge(error_store.errors) do |_key, this_val, other_val| this_val + other_val end end end end . ",
    "url": "http://localhost:4000/decouplio.github.io/error_store/",
    "relUrl": "/error_store/"
  },"7": {
    "doc": "Error store",
    "title": "How to use",
    "content": "Inside step method you can call #add_error method . add_error(key, message) . require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one end def step_one(**) false end def fail_one(**) add_error(:something_went_wrong, 'Something went wrong') end end action = SomeAction.call action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {} # Errors: # {:something_went_wrong=&gt;[\"Something went wrong\"]} action.errors # =&gt; # {:something_went_wrong=&gt;[\"Something went wrong\"]} . ",
    "url": "http://localhost:4000/decouplio.github.io/error_store/#how-to-use",
    "relUrl": "/error_store/#how-to-use"
  },"8": {
    "doc": "Error store",
    "title": "Behavior",
    "content": ". | If error was added, it doesn’t mean that action result is failure, action can be success and have errors, so basically error store is just a container for errors. Such behavior was implemented to provide more freedom. | Error store for parent an inner action should be the same. It’s because different error stores may have different add_error method signature and error hash structure. | . ",
    "url": "http://localhost:4000/decouplio.github.io/error_store/#behavior",
    "relUrl": "/error_store/#behavior"
  },"9": {
    "doc": "Error store",
    "title": "Custom error store",
    "content": "If you want to use your own custom error store then you can do it in this way: . | Define our own class with two public methods . | #add_error(&lt;signature you want&gt;) - method which adds error to error_store | #merge(error_store_to_merge) - will be used by Decouplio to merge errors from inner actions to parent action. | should have attr_reader :errors | . | . EXAMPLE (CLICK ME) require 'decouplio' class CustomErrorStore attr_reader :errors def initialize @errors = {} end def add_error(key:, message:, namespace: :root) @errors[namespace] ||= {} @errors[namespace].store( key, (@errors[namespace][key] || []) + [message].flatten ) end def merge(error_store) @errors = deep_merge(@errors, error_store.errors) end private def deep_merge(this_hash, other_hash) this_hash.merge(other_hash) do |_key, this_val, other_val| if this_val.is_a?(Hash) &amp;&amp; other_val.is_a?(Hash) deep_merge(this_val, other_val) else this_val + other_val end end end end class SomeActionWithCustomErrorStore &lt; Decouplio::Action error_store_class CustomErrorStore logic do step :step_one step :step_two end def step_one(**) add_error( key: :under_root, message: 'Error Message One' ) end def step_two(**) add_error( namespace: :step_two, key: :error_happened, message: 'Error Message Two' ) end end action = SomeActionWithCustomErrorStore.call action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {} # Errors: # {:root=&gt;{:under_root=&gt;[\"Error Message One\"]}, :step_two=&gt;{:error_happened=&gt;[\"Error Message Two\"]}} action.errors # =&gt; # {:root=&gt;{:under_root=&gt;[\"Error Message One\"]}, :step_two=&gt;{:error_happened=&gt;[\"Error Message Two\"]}} . ",
    "url": "http://localhost:4000/decouplio.github.io/error_store/#custom-error-store",
    "relUrl": "/error_store/#custom-error-store"
  },"10": {
    "doc": "Error store",
    "title": "Custom error store and inner action",
    "content": "When error store is the same for parent and inner action . EXAMPLE (CLICK ME) require 'decouplio' class CustomErrorStore attr_reader :errors def initialize @errors = {} end def add_error(key:, message:, namespace: :root) @errors[namespace] ||= {} @errors[namespace].store( key, (@errors[namespace][key] || []) + [message].flatten ) end def merge(error_store) @errors = deep_merge(@errors, error_store.errors) end private def deep_merge(this_hash, other_hash) this_hash.merge(other_hash) do |_key, this_val, other_val| if this_val.is_a?(Hash) &amp;&amp; other_val.is_a?(Hash) deep_merge(this_val, other_val) else this_val + other_val end end end end class InnerActionWithCustomErrorStore &lt; Decouplio::Action error_store_class CustomErrorStore logic do step :inner_step end def inner_step(**) add_error( namespace: :inner, key: :inner_key, message: 'Somebody was told me...' ) end end class ParentActionWithCustomErrorStore &lt; Decouplio::Action error_store_class CustomErrorStore logic do step :step_one, action: InnerActionWithCustomErrorStore step :step_two end def step_two(**) add_error( namespace: :parent, key: :error_happened, message: 'Message' ) end end action = ParentActionWithCustomErrorStore.call action # =&gt; # Result: success # Railway Flow: # step_one -&gt; inner_step -&gt; step_two # Context: # {} # Errors: # {:inner=&gt;{:inner_key=&gt;[\"Somebody was told me...\"]}, :parent=&gt;{:error_happened=&gt;[\"Message\"]}} action.errors # =&gt; # {:inner=&gt;{:inner_key=&gt;[\"Somebody was told me...\"]}, :parent=&gt;{:error_happened=&gt;[\"Message\"]}} . When error store is different for parent and inner action . If inner action error store is different from parent action error store then error will be raised. EXAMPLE (CLICK ME) require 'decouplio' class CustomErrorStore attr_reader :errors def initialize @errors = {} end def add_error(key:, message:, namespace: :root) @errors[namespace] ||= {} @errors[namespace].store( key, (@errors[namespace][key] || []) + [message].flatten ) end def merge(error_store) @errors = deep_merge(@errors, error_store.errors) end private def deep_merge(this_hash, other_hash) this_hash.merge(other_hash) do |_key, this_val, other_val| if this_val.is_a?(Hash) &amp;&amp; other_val.is_a?(Hash) deep_merge(this_val, other_val) else this_val + other_val end end end end class InnerActionWithDefaultErrorStore &lt; Decouplio::Action logic do step :inner_step end def inner_step(**) add_error( key: :inner_key, message: 'Somebody was told me...' ) end end class ParentActionForInnerActionDefaultErrorStore &lt; Decouplio::Action error_store_class CustomErrorStore logic do step :step_one, action: InnerActionWithDefaultErrorStore step :step_two end def step_two(**) add_error( namespace: :parent, key: :error_happened, message: 'Message' ) end end # =&gt; # Error store for action and inner action should be the same. (Decouplio::Errors::ErrorStoreError) . ",
    "url": "http://localhost:4000/decouplio.github.io/error_store/#custom-error-store-and-inner-action",
    "relUrl": "/error_store/#custom-error-store-and-inner-action"
  },"11": {
    "doc": "Fail",
    "title": "Fail",
    "content": "fail is the special type of step to mark failure track . ",
    "url": "http://localhost:4000/decouplio.github.io/fail/",
    "relUrl": "/fail/"
  },"12": {
    "doc": "Fail",
    "title": "Signature",
    "content": "fail(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/fail/#signature",
    "relUrl": "/fail/#signature"
  },"13": {
    "doc": "Fail",
    "title": "Behavior",
    "content": ". | when step method(#fail_one) returns truthy or falsy value then it goes to failure track(step_two step) if on_success: or on_failure: option wasn’t passed(see on_success, on_failure docs) | . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeAction.call(param_for_step_one: true) failure_action = SomeAction.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;true} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(finish_success); 2(step_one)--&gt;|failure track|4(fail_one); 4(fail_one)--&gt;|failure track|5(fail_two); 5(fail_two)--&gt;|failure track|F(finish_failure); . ",
    "url": "http://localhost:4000/decouplio.github.io/fail/#behavior",
    "relUrl": "/fail/#behavior"
  },"14": {
    "doc": "Fail",
    "title": "Options",
    "content": "on_success: . | Allowed values | Description | . | :finish_him | action stops execution if fail method returns truthy value | . | symbol with next step name | step with specified symbol name performs if step method returns truthy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_success: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessFinishHim &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :finish_him fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnSuccessFinishHim.call( param_for_step_one: true ) fail_step_success = SomeActionOnSuccessFinishHim.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnSuccessFinishHim.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;true} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(finish_success); 2(step_one)--&gt;|failure track|4(fail_one success); 2(step_one)--&gt;|failure track|7(fail_one failure); 4(fail_one success)--&gt;|failure track|5(finish_failure); 7(fail_one failure)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|5(finish_failure); . on_success: next success track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToSuccessTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :step_two step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnSuccessToSuccessTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnSuccessToSuccessTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnSuccessToSuccessTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one -&gt; step_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 2(step_one)--&gt;|failure track|6(fail_one failure); 5(fail_one success)--&gt;|success track|3(step_two); 6(fail_one failure)--&gt;|failure track|7(fail_two); 7(fail_two)--&gt;|failure track|8(finish_failure); . on_success: next failure track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToFailureTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :fail_three step :step_two fail :fail_two fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end end success_action = SomeActionOnSuccessToFailureTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnSuccessToFailureTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnSuccessToFailureTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_three=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_three); 6(fail_three)--&gt;|failure track|7(finish failure); 2(step_one)--&gt;|failure track|8(fail_one failure); 8(fail_one failure)--&gt;|failure track|9(fail_two); 9(fail_two)--&gt;|failure track|6(fail_three); . on_success: :PASS . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessPass &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :PASS end def step_one(**) ctx[:step_one] = false end def fail_one(fail_one_param:, **) ctx[:fail_one] = fail_one_param end end fail_step_success = SomeActionOnSuccessPass.call(fail_one_param: true) fail_step_failure = SomeActionOnSuccessPass.call(fail_one_param: false) fail_step_success # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; true # :step_one =&gt; false # :fail_one =&gt; true # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; false # :step_one =&gt; false # :fail_one =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|failure track|3(fail_one); 3(fail_one)--&gt;|on_success: :PASS|5(finish_success); 3(fail_one)--&gt;|failure track|4(finish_failure); . on_success: :FAIL . It will perform like regular fail step, just move to next failure track step. on_failure: . | Allowed values | Description | . | :finish_him | action stops execution if fail method returns falsy value | . | symbol with next step name | step with specified symbol name performs if step method returns falsy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_failure: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureFinishHim &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :finish_him step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnFailureFinishHim.call( param_for_step_one: true ) fail_step_success = SomeActionOnFailureFinishHim.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnFailureFinishHim.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(finish failure); 2(step_one)--&gt;|failure track|8(fail_one failure); 8(fail_one failure)--&gt;|failure track|7(finish failure); . on_failure: next success track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToSuccessTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :step_two step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnFailureToSuccessTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnFailureToSuccessTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnFailureToSuccessTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one -&gt; step_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :step_two=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 8(fail_one failure)--&gt;|success track|3(step_two); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(finish_failure); 2(step_one)--&gt;|failure track|8(fail_one failure); . on_failure: next failure track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToFailureTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :fail_three step :step_two fail :fail_two fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end end success_action = SomeActionOnFailureToFailureTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnFailureToFailureTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnFailureToFailureTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(fail_three); 7(fail_three)--&gt;|failure track|8(finish failure); 2(step_one)--&gt;|failure track|9(fail_one failure); 9(fail_one failure)--&gt;|failure track|7(fail_three); . on_failure: :PASS . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailurePass &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :PASS end def step_one(**) false end def fail_one(fail_one_param:, **) ctx[:fail_one] = fail_one_param end end fail_step_success = SomeActionOnFailurePass.call(fail_one_param: true) fail_step_failure = SomeActionOnFailurePass.call(fail_one_param: false) fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; true # :fail_one =&gt; true # Errors: # {} fail_step_failure # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; false # :fail_one =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|failure track|3(fail_one); 3(fail_one)--&gt;|failure track|4(finish_failure); 3(fail_one)--&gt;|on_failure: :PASS|5(finish_success); . on_failure: :FAIL . It will perform like regular fail step, just move to next failure track step. on_error: any value allowed for on_success or on_failure . Behaves in the same way as on_error for step . if: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnIfCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two, if: :some_condition? fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end def some_condition?(if_condition_param:, **) if_condition_param end end success_action = SomeActionOnIfCondition.call( param_for_step_one: true ) fail_condition_positive = SomeActionOnIfCondition.call( param_for_step_one: false, if_condition_param: true ) fail_condition_negative = SomeActionOnIfCondition.call( param_for_step_one: false, if_condition_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_condition_positive # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} fail_condition_negative # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;false, :action_failed=&gt;true, :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|condition positive|6(fail_two); 6(fail_two)--&gt;|failure track|7(fail_three); 5(fail_one)--&gt;|condition negative|7(fail_three); 7(fail_three)--&gt;|failure track|8(finish failure); . unless: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnUnlessCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two, unless: :some_condition? fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end def some_condition?(if_condition_param:, **) if_condition_param end end success_action = SomeActionOnUnlessCondition.call( param_for_step_one: true ) fail_condition_positive = SomeActionOnUnlessCondition.call( param_for_step_one: false, if_condition_param: false ) fail_condition_negative = SomeActionOnUnlessCondition.call( param_for_step_one: false, if_condition_param: true ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_condition_positive # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;false, :action_failed=&gt;true, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} fail_condition_negative # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;true, :action_failed=&gt;true, :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|condition positive|6(fail_two); 6(fail_two)--&gt;|failure track|7(fail_three); 5(fail_one)--&gt;|condition negative|7(fail_three); 7(fail_three)--&gt;|failure track|8(finish failure); . finish_him: :on_success . The same behavior as for on_success: :finish_him . finish_him: :on_failure . The same behavior as for on_failure: :finish_him . finish_him: true . Will finish action execution anyway . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionFinishHimTrue &lt; Decouplio::Action logic do step :step_one fail :fail_one, finish_him: true step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionFinishHimTrue.call( param_for_step_one: true ) fail_step_success = SomeActionFinishHimTrue.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionFinishHimTrue.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(finish failure); 2(step_one)--&gt;|failure track|7(fail_one failure); 7(fail_one failure)--&gt;|failure track|6(finish failure); . ",
    "url": "http://localhost:4000/decouplio.github.io/fail/#options",
    "relUrl": "/fail/#options"
  },"15": {
    "doc": "Home",
    "title": "Decouplio",
    "content": "Decouplio is a zero dependency, thread safe and framework agnostic gem designed to encapsulate application business logic. It’s reverse engineered through TDD and inspired by such frameworks and gems like Trailblazer, Interactor. ",
    "url": "http://localhost:4000/decouplio.github.io/#decouplio",
    "relUrl": "/#decouplio"
  },"16": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/",
    "relUrl": "/"
  },"17": {
    "doc": "Inner action",
    "title": "Inner Action",
    "content": "step/fail/pass steps can perform another action instead of method. require 'decouplio' class InnerAction &lt; Decouplio::Action logic do step :step_one step :step_two end def step_one(**) ctx # =&gt; ctx from parent action(SomeAction) ctx[:step_one] = 'Success' end def step_two(**) ctx # =&gt; ctx from parent action(SomeAction) ctx[:step_two] = 'Success' end end class SomeAction &lt; Decouplio::Action logic do step InnerAction # OR # fail InnerAction # OR # pass InnerAction end end action = SomeAction.call action # =&gt; # Result: success # Railway Flow: # InnerAction -&gt; step_one -&gt; step_two # Context: # {:step_one=&gt;\"Success\", :step_two=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(any_name); subgraph inner action; 2(step_one)--&gt;|success track|3(step_two); end; 3(step_two)--&gt;|success track|4(finish success); The parent action context will be passed into inner action . ",
    "url": "http://localhost:4000/decouplio.github.io/inner_action/#inner-action",
    "relUrl": "/inner_action/#inner-action"
  },"18": {
    "doc": "Inner action",
    "title": "Options",
    "content": "All options for step/fail/pass can be applied for inner action step. ",
    "url": "http://localhost:4000/decouplio.github.io/inner_action/#options",
    "relUrl": "/inner_action/#options"
  },"19": {
    "doc": "Inner action",
    "title": "Inner action",
    "content": " ",
    "url": "http://localhost:4000/decouplio.github.io/inner_action/",
    "relUrl": "/inner_action/"
  },"20": {
    "doc": "Logic block",
    "title": "Logic block",
    "content": "It’s just a block witch contains flow logic . require 'decouplio' class SomeAction &lt; Decouplio::Action logic do # define your logic here end end . What to put inside logic block? . See below: . ",
    "url": "http://localhost:4000/decouplio.github.io/logic_block/",
    "relUrl": "/logic_block/"
  },"21": {
    "doc": "Octo",
    "title": "Octo",
    "content": "It’s a step type which helps to implement strategy pattern. ",
    "url": "http://localhost:4000/decouplio.github.io/octo/",
    "relUrl": "/octo/"
  },"22": {
    "doc": "Octo",
    "title": "Signature",
    "content": "octo(octo_name, ctx_key:, method:, **options) do on :key1, palp: :palp_name_one on :key2, palp: :palp_name_two on :key3, palp: :palp_name_three end . ",
    "url": "http://localhost:4000/decouplio.github.io/octo/#signature",
    "relUrl": "/octo/#signature"
  },"23": {
    "doc": "Octo",
    "title": "Behavior",
    "content": ". | Depending on some value you can perform different flow. Imagine that octo will be replaced with another flow. | You have two options to set value for octo. By ctx_key and method options. | ctx_key and method options are controversial, so you can use only one of them. | with ctx_key you can specify the key inside action context with value for octo | with method you can specify method name symbol, which will be called to retrieve octo value, like we do for if and unless options. | . logic do palp :palp_name_one do step :step_one, on_failure: :step_final step :step_two end palp :palp_name_two do step :step_two step :step_three end palp :palp_name_three do step :step_three step :step_one end step :init_step octo :octo_name, ctx_key: :some_key do on :key1, palp: :palp_name_one on :key2, palp: :palp_name_two on :key3, palp: :palp_name_three end step :step_final end . flowchart TD; 0(init_step)--&gt;1(octo); 1(octo)--&gt;|when ctx_key value == :key1|12(palp_name_one); 12(palp_name_one)--&gt;3(step_one); 3(step_one)--&gt;4(step_two); 1(octo)--&gt;|when ctx_key value == :key2|13(palp_name_two); 13(palp_name_two)--&gt;6(step_two); 6(step_two)--&gt;7(step_three); 1(octo)--&gt;|when ctx_key value == :key3|14(palp_name_three); 14(palp_name_three)--&gt;9(step_three); 9(step_three)--&gt;10(step_one); 4(step_two)--&gt;11(final_step); 7(step_three)--&gt;11(final_step); 10(step_one)--&gt;11(final_step); Palp . Currently only one possibility is present to define flow for octo, it’s palp . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do # it doesn't matter where you define palp # at the beginning of logic block # or at the end or in the middle palp :option_one_palp do step :step_one, on_failure: :final_step step :step_two end palp :option_two_palp do step :step_two step :step_three end palp :option_three_palp do step :step_three step :step_one fail :fail_one end step :init_step octo :my_octo, ctx_key: :custom_key do on :option_one, palp: :option_one_palp on :option_two, palp: :option_two_palp on :option_three, palp: :option_three_palp end step :final_step fail :fail_two end def init_step(octo_key:, **) ctx[:custom_key] = octo_key end def step_one(param_for_step_one:, **) ctx[:step_one] = param_for_step_one end def step_two(param_for_step_two:, **) ctx[:step_two] = param_for_step_two end def step_three(param_for_step_three:, **) ctx[:step_three] = param_for_step_three end def fail_one(**) ctx[:fail_one] = 'Failure' end def final_step(**) ctx[:final_step] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end octo_option_one_success = SomeAction.call( octo_key: :option_one, param_for_step_one: true, param_for_step_two: true ) octo_option_one_failure = SomeAction.call( octo_key: :option_one, param_for_step_one: false, param_for_step_two: true ) octo_option_two_success = SomeAction.call( octo_key: :option_two, param_for_step_two: true, param_for_step_three: true ) octo_option_two_failure = SomeAction.call( octo_key: :option_two, param_for_step_two: true, param_for_step_three: false ) octo_option_three_success = SomeAction.call( octo_key: :option_three, param_for_step_one: true, param_for_step_three: true ) octo_option_three_failure = SomeAction.call( octo_key: :option_three, param_for_step_one: false, param_for_step_three: true ) octo_option_one_success # =&gt; # Result: success # Railway Flow: # init_step -&gt; my_octo -&gt; step_one -&gt; step_two -&gt; final_step # Context: # {:octo_key=&gt;:option_one, :param_for_step_one=&gt;true, :param_for_step_two=&gt;true, :custom_key=&gt;:option_one, :step_one=&gt;true, :step_two=&gt;true, :final_step=&gt;\"Success\"} # Errors: # {} octo_option_one_failure # =&gt; # Result: success # Railway Flow: # init_step -&gt; my_octo -&gt; step_one -&gt; final_step # Context: # {:octo_key=&gt;:option_one, :param_for_step_one=&gt;false, :param_for_step_two=&gt;true, :custom_key=&gt;:option_one, :step_one=&gt;false, :final_step=&gt;\"Success\"} # Errors: # {} octo_option_two_success # =&gt; # Result: success # Railway Flow: # init_step -&gt; my_octo -&gt; step_two -&gt; step_three -&gt; final_step # Context: # {:octo_key=&gt;:option_two, :param_for_step_two=&gt;true, :param_for_step_three=&gt;true, :custom_key=&gt;:option_two, :step_two=&gt;true, :step_three=&gt;true, :final_step=&gt;\"Success\"} # Errors: # {} octo_option_two_failure # =&gt; # Result: failure # Railway Flow: # init_step -&gt; my_octo -&gt; step_two -&gt; step_three -&gt; fail_two # Context: # {:octo_key=&gt;:option_two, :param_for_step_two=&gt;true, :param_for_step_three=&gt;false, :custom_key=&gt;:option_two, :step_two=&gt;true, :step_three=&gt;false, :fail_two=&gt;\"Failure\"} # Errors: # {} octo_option_three_success # =&gt; # Result: success # Railway Flow: # init_step -&gt; my_octo -&gt; step_three -&gt; step_one -&gt; final_step # Context: # {:octo_key=&gt;:option_three, :param_for_step_one=&gt;true, :param_for_step_three=&gt;true, :custom_key=&gt;:option_three, :step_three=&gt;true, :step_one=&gt;true, :final_step=&gt;\"Success\"} # Errors: # {} octo_option_three_failure # =&gt; # Result: failure # Railway Flow: # init_step -&gt; my_octo -&gt; step_three -&gt; step_one -&gt; fail_one -&gt; fail_two # Context: # {:octo_key=&gt;:option_three, :param_for_step_one=&gt;false, :param_for_step_three=&gt;true, :custom_key=&gt;:option_three, :step_three=&gt;true, :step_one=&gt;false, :fail_one=&gt;\"Failure\", :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart TD; 1(start)--&gt;2(init_step); 2(init_step)--&gt;|success track|3(octo); 2(init_step)--&gt;|failure track|11(fail_two); 3(octo)--&gt;|custom_key value == :option_one|4(option_one_palp); 4(option_one_palp)--&gt;|success track|5(step_one); 5(step_one)--&gt;|success track|6(step_two); 6(step_two)--&gt;|success track|7(final_step); 5(step_one)--&gt;|failure track|7(final_step); 6(step_two)--&gt;|failure track|11(fail_two); 3(octo)--&gt;|custom_key value == :option_two|8(option_two_palp); 8(option_two_palp)--&gt;|success track|9(step_two); 9(step_two)--&gt;|success track|10(step_three); 9(step_two)--&gt;|failure track|11(fail_two); 10(step_three)--&gt;|success track|7(final_step); 10(step_three)--&gt;|failure track|11(fail_two); 3(octo)--&gt;|custom_key value == :option_three|12(option_three_palp); 12(option_three_palp)--&gt;|success track|13(step_three); 13(step_three)--&gt;|success track|14(step_one); 14(step_one)--&gt;|success track|7(final_step); 13(step_three)--&gt;|failure track|15(fail_one); 14(step_one)--&gt;|failure track|15(fail_one); 15(fail_one)--&gt;|failure track|11(fail_two); . ",
    "url": "http://localhost:4000/decouplio.github.io/octo/#behavior",
    "relUrl": "/octo/#behavior"
  },"24": {
    "doc": "Octo",
    "title": "Options",
    "content": "ctx_key: context key with octo value . See examples above . method: method symbol which returns octo value . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do palp :palp_one do step :step_one end palp :palp_two do step :step_two end octo :octo_name, method: :what_is_next? do on :option_one, palp: :palp_one on :option_two, palp: :palp_two end end def step_one(**) # ... end def step_two(**) # ... end def what_is_next?(connection:, url:) connection.get(url).body[:decision] end end . if: condition method name . The same as for step . unless: condition method name . The same as for step . ",
    "url": "http://localhost:4000/decouplio.github.io/octo/#options",
    "relUrl": "/octo/#options"
  },"25": {
    "doc": "Pass",
    "title": "Pass",
    "content": "pass is the step type that always moves to success track logic steps . ",
    "url": "http://localhost:4000/decouplio.github.io/pass/",
    "relUrl": "/pass/"
  },"26": {
    "doc": "Pass",
    "title": "Signature",
    "content": "pass(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/pass/#signature",
    "relUrl": "/pass/#signature"
  },"27": {
    "doc": "Pass",
    "title": "Behavior",
    "content": ". | when step method(#pass_one) returns truthy or falsy value then it goes to success track(step_two step) | . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do pass :pass_one step :step_two fail :fail_one end def pass_one(param_for_pass:, **) ctx[:pass_one] = param_for_pass end def step_two(**) ctx[:step_two] = 'Success' end def fail_one(**) ctx[:fail_one] = 'Failure' end end pass_success = SomeAction.call(param_for_pass: true) pass_failure = SomeAction.call(param_for_pass: false) pass_success # =&gt; # Result: success # Railway Flow: # pass_one -&gt; step_two # Context: # {:param_for_pass=&gt;true, :pass_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} pass_failure # =&gt; # Result: success # Railway Flow: # pass_one -&gt; step_two # Context: # {:param_for_pass=&gt;false, :pass_one=&gt;false, :step_two=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(pass_one success); 1(start)--&gt;3(pass_one failure); 2(pass_one success)--&gt;|success track|4(step_two); 3(pass_one failure)--&gt;|success track|4(step_two); 4(step_two)--&gt;|success track|5(finish_success) . ",
    "url": "http://localhost:4000/decouplio.github.io/pass/#behavior",
    "relUrl": "/pass/#behavior"
  },"28": {
    "doc": "Pass",
    "title": "Options",
    "content": "on_error: any value allowed for on_success or on_failure . Behaves in the same way as on_error for step . if: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionIfCondition &lt; Decouplio::Action logic do step :step_one pass :pass_one, if: :some_condition? step :step_two end def step_one(**) ctx[:step_one] = 'Success' end def pass_one(**) ctx[:pass_one] = 'Success' end def step_two(**) ctx[:step_two] = 'Success' end def some_condition?(condition_param:, **) condition_param end end condition_positive = SomeActionIfCondition.call(condition_param: true) condition_negative = SomeActionIfCondition.call(condition_param: false) condition_positive # =&gt; # Result: success # Railway Flow: # step_one -&gt; pass_one -&gt; step_two # Context: # {:condition_param=&gt;true, :step_one=&gt;\"Success\", :pass_one=&gt;\"Success\", :step_two=&gt;\"Success\"} # Errors: # {} condition_negative # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:condition_param=&gt;false, :step_one=&gt;\"Success\", :step_two=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|condition positive|3(pass_one); 3(pass_one)--&gt;|success track|4(step_two); 2(step_one)--&gt;|condition negative|4(step_two); 4(step_two)--&gt;|success track|5(finish_success); . unless: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionUnlessCondition &lt; Decouplio::Action logic do step :step_one pass :pass_one, unless: :some_condition? step :step_two end def step_one(**) ctx[:step_one] = 'Success' end def pass_one(**) ctx[:pass_one] = 'Success' end def step_two(**) ctx[:step_two] = 'Success' end def some_condition?(condition_param:, **) condition_param end end condition_positive = SomeActionUnlessCondition.call(condition_param: false) condition_negative = SomeActionUnlessCondition.call(condition_param: true) condition_positive # =&gt; # Result: success # Railway Flow: # step_one -&gt; pass_one -&gt; step_two # Context: # {:condition_param=&gt;false, :step_one=&gt;\"Success\", :pass_one=&gt;\"Success\", :step_two=&gt;\"Success\"} # Errors: # {} condition_negative # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:condition_param=&gt;true, :step_one=&gt;\"Success\", :step_two=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|condition positive|3(pass_one); 3(pass_one)--&gt;|success track|4(step_two); 2(step_one)--&gt;|condition negative|4(step_two); 4(step_two)--&gt;|success track|5(finish_success); . finish_him: true . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionFinishHim &lt; Decouplio::Action logic do step :step_one, on_success: :step_two, on_failure: :pass_one pass :pass_one, finish_him: true step :step_two step :step_three end def step_one(param_for_step:, **) ctx[:step_one] = param_for_step end def pass_one(**) ctx[:pass_one] = 'Success' end def step_two(**) ctx[:step_two] = 'Success' end def step_three(**) ctx[:step_three] = 'Success' end end success_track = SomeActionFinishHim.call(param_for_step: true) failure_track = SomeActionFinishHim.call(param_for_step: false) success_track # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step=&gt;true, :step_one=&gt;true, :step_two=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} failure_track # =&gt; # Result: success # Railway Flow: # step_one -&gt; pass_one # Context: # {:param_for_step=&gt;false, :step_one=&gt;false, :pass_one=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(step_three); 2(step_one)--&gt;|failure track|5(pass_one); 4(step_three)--&gt;|success track|6(finish success); 5(pass_one)--&gt;|success track|6(finish success); . ",
    "url": "http://localhost:4000/decouplio.github.io/pass/#options",
    "relUrl": "/pass/#options"
  },"29": {
    "doc": "Quick start",
    "title": "Quick start",
    "content": "Installation . Regular installation . gem install decouplio . Gemfile . gem 'decouplio' . Usage . All you need to do is to create new class and inherit it from Decouplio::Action, define your action logic and implement methods. require 'decouplio' class ProcessNumber &lt; Decouplio::Action logic do step :multiply step :divide end def multiply(number:, multiplier:, **) ctx[:result] = number * multiplier end def divide(result:, divider:, **) ctx[:result] = result / divider end end action = ProcessNumber.call(number: 5, multiplier: 4, divider: 10) # =&gt; # Result: success # Railway Flow: # multiply -&gt; divide # Context: # {:number=&gt;5, :multiplier=&gt;4, :divider=&gt;10, :result=&gt;2} # Errors: # {} action[:number] # =&gt; 5 action[:multiplier] # =&gt; 4 action[:divider] # =&gt; 10 action[:result] # =&gt; 2 action.success? # =&gt; true action.failure? # =&gt; false action.railway_flow # =&gt; [:multiply, :divide] # OR class RaisingAction &lt; Decouplio::Action logic do step :step_one step :step_two end def step_one(step_one_param:, **) ctx[:step_one] = step_one_param end def step_two(**) ctx[:step_two] = 'Success' end end begin RaisingAction.call!(step_one_param: false) rescue Decouplio::Errors::ExecutionError =&gt; exception exception.message # =&gt; Action failed. exception.action # =&gt; # Result: failure # Railway Flow: # step_one # Context: # :step_one_param =&gt; false # :step_one =&gt; false # Errors: # None end . ",
    "url": "http://localhost:4000/decouplio.github.io/quick_start/",
    "relUrl": "/quick_start/"
  },"30": {
    "doc": "Resq",
    "title": "Resq",
    "content": "Step type which can be use to handle errors raised during step invocation. ",
    "url": "http://localhost:4000/decouplio.github.io/resq/",
    "relUrl": "/resq/"
  },"31": {
    "doc": "Resq",
    "title": "Signature",
    "content": "resq(**options) . ",
    "url": "http://localhost:4000/decouplio.github.io/resq/#signature",
    "relUrl": "/resq/#signature"
  },"32": {
    "doc": "Resq",
    "title": "Allowed for steps",
    "content": "| Step type | Allowed | . | step | Yes | . | fail | Yes | . | pass | Yes | . | wrap | Yes | . | octo | NO | . ",
    "url": "http://localhost:4000/decouplio.github.io/resq/#allowed-for-steps",
    "relUrl": "/resq/#allowed-for-steps"
  },"33": {
    "doc": "Resq",
    "title": "Behavior",
    "content": ". | When resq step is defined after allowed step then it will catch error with class specified in options and call handler method. | resq applies only for step which is defined above. | After resq performed handler method, next failure track step will be performed. | . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one resq handler_method: ArgumentError step :step_two fail :fail_one end def step_one(lambda_for_step_one:, **) ctx[:step_one] = lambda_for_step_one.call end def step_two(**) ctx[:step_two] = 'Success' end def fail_one(**) ctx[:fail_one] = 'Failure' end def handler_method(error, **this_is_ctx) ctx[:error] = error.message end end success_action = SomeAction.call(lambda_for_step_one: -&gt; { true }) failure_action = SomeAction.call(lambda_for_step_one: -&gt; { false }) erroneous_action = SomeAction.call( lambda_for_step_one: -&gt; { raise ArgumentError, 'some error message' } ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000561525a05628 resq.rb:32 (lambda)&gt;, :step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000561525a04f48 resq.rb:33 (lambda)&gt;, :step_one=&gt;false, :fail_one=&gt;\"Failure\"} # Errors: # {} erroneous_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; handler_method -&gt; fail_one # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000561525a04b60 resq.rb:35 (lambda)&gt;, :error=&gt;\"some error message\", :fail_one=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|failure track|6(finish failure); 2(step_one)--&gt;|error track|7(handler_method); 7(handler_method)--&gt;|error track|5(fail_one); . ",
    "url": "http://localhost:4000/decouplio.github.io/resq/#behavior",
    "relUrl": "/resq/#behavior"
  },"34": {
    "doc": "Resq",
    "title": "When several error handlers and error classes",
    "content": "EXAMPLE (CLICK ME) require 'decouplio' class SomeActionSeveralHandlersErrorClasses &lt; Decouplio::Action logic do step :step_one resq handler_method_one: [ArgumentError, NoMethodError], handler_method_two: NotImplementedError step :step_two fail :fail_one end def step_one(lambda_for_step_one:, **) ctx[:step_one] = lambda_for_step_one.call end def step_two(**) ctx[:step_two] = 'Success' end def fail_one(**) ctx[:fail_one] = 'Failure' end def handler_method_one(error, **this_is_ctx) ctx[:error] = error.message end def handler_method_two(error, **this_is_ctx) ctx[:error] = error.message end end success_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { true } ) failure_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { false } ) argument_error_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { raise ArgumentError, 'Argument error message' } ) no_method_error_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { raise NoMethodError, 'NoMethodError error message' } ) no_implemented_error_action = SomeActionSeveralHandlersErrorClasses.call( lambda_for_step_one: -&gt; { raise NotImplementedError, 'NotImplementedError error message' } ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000557a7149f638 resq.rb:106 (lambda)&gt;, :step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000557a7149f390 resq.rb:109 (lambda)&gt;, :step_one=&gt;false, :fail_one=&gt;\"Failure\"} # Errors: # {} argument_error_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; handler_method_one -&gt; fail_one # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000557a7149f138 resq.rb:112 (lambda)&gt;, :error=&gt;\"Argument error message\", :fail_one=&gt;\"Failure\"} # Errors: # {} no_method_error_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; handler_method_one -&gt; fail_one # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000557a7149edc8 resq.rb:115 (lambda)&gt;, :error=&gt;\"NoMethodError error message\", :fail_one=&gt;\"Failure\"} # Errors: # {} no_implemented_error_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; handler_method_two -&gt; fail_one # Context: # {:lambda_for_step_one=&gt;#&lt;Proc:0x0000557a7149e8c8 resq.rb:118 (lambda)&gt;, :error=&gt;\"NotImplementedError error message\", :fail_one=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|failure track|6(finish failure); 2(step_one)--&gt;|ArgumentError|7(handler_method_one); 2(step_one)--&gt;|NoMethodError|9(handler_method_one); 2(step_one)--&gt;|NotImplementedError|8(handler_method_two); 7(handler_method_one)--&gt;|error track|5(fail_one); 9(handler_method_one)--&gt;|error track|5(fail_one); 8(handler_method_two)--&gt;|error track|5(fail_one); . ",
    "url": "http://localhost:4000/decouplio.github.io/resq/#when-several-error-handlers-and-error-classes",
    "relUrl": "/resq/#when-several-error-handlers-and-error-classes"
  },"35": {
    "doc": "Step",
    "title": "Step",
    "content": "step is the basic type of logic steps . ",
    "url": "http://localhost:4000/decouplio.github.io/step/",
    "relUrl": "/step/"
  },"36": {
    "doc": "Step",
    "title": "Signature",
    "content": "step(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/step/#signature",
    "relUrl": "/step/#signature"
  },"37": {
    "doc": "Step",
    "title": "Behavior",
    "content": ". | when step method(#step_one) returns truthy value then it goes to success track(step_two step) | when step method(#step_one) returns falsy value then it goes to failure track(fail_one step) | . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end end success_action = SomeAction.call(param_for_step_one: true) failure_action = SomeAction.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true} # Errors: # {} . flowchart LR; A(start)--&gt;B(step_one); B(step_one)--&gt;|success track|C(step_two); B(step_one)--&gt;|failure track|D(fail_one); C(step_two)--&gt;|success track|E(finish_success); D(fail_one)--&gt;|failure track|F(finish_failure); . ",
    "url": "http://localhost:4000/decouplio.github.io/step/#behavior",
    "relUrl": "/step/#behavior"
  },"38": {
    "doc": "Step",
    "title": "Options",
    "content": "on_success: . | Allowed values | Description | . | :finish_him | action stops execution if step method returns truthy value | . | symbol with next step name | step with specified symbol name performs if step method returns truthy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_success: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessFinishHim &lt; Decouplio::Action logic do step :step_one, on_success: :finish_him fail :fail_one step :step_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end end success_action = SomeActionOnSuccessFinishHim.call(param_for_step_one: true) failure_action = SomeActionOnSuccessFinishHim.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;true} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(finish_success); 2(step_one)--&gt;|failure track|4(fail_one); 4(fail_one)--&gt;|failure track|5(finish_failure); . on_success: next success track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToSuccessTrack &lt; Decouplio::Action logic do step :step_one, on_success: :step_three fail :fail_one step :step_two step :step_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def step_three(**) ctx[:result] = 'Result' end end success_action = SomeActionOnSuccessToSuccessTrack.call(param_for_step_one: true) failure_action = SomeActionOnSuccessToSuccessTrack.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Result\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true} # Errors: # {} . flowchart LR; A(start)--&gt;B(step_one); B(step_one)--&gt;|success track|C(step_three); B(step_one)--&gt;|failure track|D(fail_one); C(step_three)--&gt;|success track|E(finish_success); D(fail_one)--&gt;|failure track|F(finish_failure); . on_success: next failure track step . Can be used if for some reason you need to jump to fail step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToFailureTrack &lt; Decouplio::Action logic do step :step_one, on_success: :fail_two fail :fail_one step :step_two step :step_three fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def step_three(**) ctx[:result] = 'Result' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnSuccessToFailureTrack.call(param_for_step_one: true) failure_action = SomeActionOnSuccessToFailureTrack.call(param_for_step_one: false) success_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(fail_two); 2(step_one)--&gt;|failure track|4(fail_one); 4(fail_one)--&gt;|failure track|3(fail_two); 3(fail_two)--&gt;|failure track|5(finish_failure); . on_success: :PASS . It will perform like regular step, just move to next success track step. on_success: :FAIL . It will perform next failure track step OR finish action as failure in case if step is the last step. EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessFail &lt; Decouplio::Action logic do step :step_one step :step_two, on_success: :FAIL end def step_one(**) ctx[:step_one] = 'Success' end def step_two(step_two_param:, **) ctx[:step_two] = step_two_param end end success_action = SomeActionOnSuccessFail.call(step_two_param: true) failure_action = SomeActionOnSuccessFail.call(step_two_param: false) success_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; true # :step_one =&gt; \"Success\" # :step_two =&gt; true # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; false # :step_one =&gt; \"Success\" # :step_two =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_failure); 3(step_two)--&gt;|failure track|5(finish_failure); . on_failure: . | Allowed values | Description | . | :finish_him | action stops execution if step method returns falsy value | . | symbol with next step name | step with specified symbol name performs if step method returns falsy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_failure: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureFinishHim &lt; Decouplio::Action logic do step :step_one, on_failure: :finish_him fail :fail_one step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end end success_action = SomeActionOnFailureFinishHim.call(param_for_step_one: true) failure_action = SomeActionOnFailureFinishHim.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;false} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|5(finish_success); 2(step_one)--&gt;|failure track|4(finish_failure); . on_failure: next success track step . Can be used in case if you need to come back to success track . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToSuccessTrack &lt; Decouplio::Action logic do step :step_one, on_failure: :step_three fail :fail_one step :step_two fail :fail_two step :step_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end end success_action = SomeActionOnFailureToSuccessTrack.call(param_for_step_one: true) failure_action = SomeActionOnFailureToSuccessTrack.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_three # Context: # {:param_for_step_one=&gt;false, :step_three=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(step_three); 4(step_three)--&gt;|success track|5(finish_success); 2(step_one)--&gt;|failure track|4(step_three); . on_failure: next failure track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToFailureTrack &lt; Decouplio::Action logic do step :step_one, on_failure: :fail_two fail :fail_one step :step_two fail :fail_two step :step_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end end success_action = SomeActionOnFailureToFailureTrack.call(param_for_step_one: true) failure_action = SomeActionOnFailureToFailureTrack.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_two=&gt;\"failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(step_three); 4(step_three)--&gt;|success track|5(finish_success); 2(step_one)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(finish_failure); . on_failure: :PASS . It will perform next success track step OR finish action as success if it’s the last step. EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailurePass &lt; Decouplio::Action logic do step :step_one step :step_two, on_failure: :PASS end def step_one(**) ctx[:step_one] = true end def step_two(step_two_param:, **) ctx[:step_two] = step_two_param end end success_action = SomeActionOnFailurePass.call(step_two_param: true) failure_action = SomeActionOnFailurePass.call(step_two_param: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; true # :step_one =&gt; true # :step_two =&gt; true # Errors: # {} failure_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; false # :step_one =&gt; true # :step_two =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 3(step_two)--&gt;|failure track|5(finish_success); . on_failure: :FAIL . It will perform like regular step, just move to next failure track step. on_error: any value allowed for on_success or on_failure . on_error option is used in case when resq step is applied to step, fail, pass, wrap. If step raises an error then handler method will be executed and after execution flow will directed to value you specified for on_error option. EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnErrorNextSuccessTrackStep &lt; Decouplio::Action logic do step :step_one, on_error: :step_three resq handle_step_one: ArgumentError fail :fail_one step :step_two step :step_three end def step_one(step_one_lambda:, **) ctx[:step_one] = step_one_lambda.call end def fail_one(**) ctx[:fail_one] = 'Failure' end def step_two(**) ctx[:step_two] = 'Success' end def step_three(**) ctx[:step_three] = 'Success' end def handle_step_one(error, **) ctx[:handle_step_one] = error.message end end success_action = SomeActionOnErrorNextSuccessTrackStep.call( step_one_lambda: -&gt; { true } ) failed_action = SomeActionOnErrorNextSuccessTrackStep.call( step_one_lambda: -&gt; { false } ) erroneous_action = SomeActionOnErrorNextSuccessTrackStep.call( step_one_lambda: -&gt; { raise ArgumentError, 'Some message' } ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # :step_one_lambda =&gt; #&lt;Proc:0x00007f1e4ae0aaa0 step.rb:664 (lambda)&gt; # :step_one =&gt; true # :step_two =&gt; \"Success\" # :step_three =&gt; \"Success\" # Errors: # None failed_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # :step_one_lambda =&gt; #&lt;Proc:0x00007f1e4ae0a258 step.rb:665 (lambda)&gt; # :step_one =&gt; false # :fail_one =&gt; \"Failure\" # Errors: # None erroneous_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; handle_step_one -&gt; step_three # Context: # :step_one_lambda =&gt; #&lt;Proc:0x00007f1e4ae09b78 step.rb:666 (lambda)&gt; # :handle_step_one =&gt; \"Some message\" # :step_three =&gt; \"Success\" # Errors: # None . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(step_three); 4(step_three)--&gt;|success track|5(finish_success); 2(step_one)--&gt;|failure track|6(fail_one); 6(fail_one)--&gt;|failure track|7(finish_failure); 2(step_one)--&gt;|error track|8(handler_step_one); 8(handler_step_one)--&gt;|success track|4(step_three); . if: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnIfCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two step :step_three, if: :step_condition? end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end def step_condition?(step_condition_param:, **) step_condition_param end end condition_positive = SomeActionOnIfCondition.call( param_for_step_one: true, step_condition_param: true ) condition_negative = SomeActionOnIfCondition.call( param_for_step_one: true, step_condition_param: false ) condition_positive # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;true, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} condition_negative # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;false, :result=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|condition positive|3(step_two); 3(step_two)--&gt;|condition positive|4(step_three); 4(step_three)--&gt;|condition positive|5(finish_success); 2(step_one)--&gt;|condition negative|6(step_two); 6(step_two)--&gt;|condition negative|7(finish_success); . unless: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnUnlessCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two step :step_three, unless: :step_condition? end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end def step_condition?(step_condition_param:, **) step_condition_param end end condition_positive = SomeActionOnUnlessCondition.call( param_for_step_one: true, step_condition_param: true ) condition_negative = SomeActionOnUnlessCondition.call( param_for_step_one: true, step_condition_param: false ) condition_positive # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;true, :result=&gt;\"Success\"} # Errors: # {} condition_negative # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;false, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|condition positive|3(step_two); 3(step_two)--&gt;|condition positive|4(finish_success); 2(step_one)--&gt;|condition negative|5(step_two); 5(step_two)--&gt;|condition negative|6(step_three); 6(step_three)--&gt;|condition negative|7(finish_success); . finish_him: :on_success . The same behavior as for on_success: :finish_him . finish_him: :on_failure . The same behavior as for on_failure: :finish_him . finish_him: :on_error . The same behavior as for on_error: :finish_him . ",
    "url": "http://localhost:4000/decouplio.github.io/step/#options",
    "relUrl": "/step/#options"
  },"39": {
    "doc": "Step as a service",
    "title": "Step as a service",
    "content": "It’s similar to Inner action, but instead of using Decouplio::Action, you can use PORO class. ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/",
    "relUrl": "/step_as_a_service/"
  },"40": {
    "doc": "Step as a service",
    "title": "Signature",
    "content": "(step|fail|pass)(service_class, **options) . ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/#signature",
    "relUrl": "/step_as_a_service/#signature"
  },"41": {
    "doc": "Step as a service",
    "title": "Behavior",
    "content": ". | service class should implement .call class method | service class can be used as step or fail or pass | all options of step|fail|pass can be used as for Inner action | depending on returning value of .call method(truthy ot falsy) the execution will be moved to success or failure track accordingly. | . ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/#behavior",
    "relUrl": "/step_as_a_service/#behavior"
  },"42": {
    "doc": "Step as a service",
    "title": "How to use?",
    "content": "Create a PORO class with .call class method. # :ctx - it's a ctx from Decouplio::Action # :error_store - it's an error_store from Decouplio::Action, # you can call #add_error on it class Concat def self.call(ctx:, **) new(ctx: ctx).call end def initialize(ctx:) @ctx = ctx end def call @ctx[:result] = @ctx[:one] + @ctx[:two] end end # OR # :ctx - it's a ctx from Decouplio::Action # :error_store - it's an error_store from Decouplio::Action, # you can call #add_error on it class Subtract def self.call(ctx:, **) ctx[:result] = ctx[:one] - ctx[:two] end end # OR class MakeRequest def self.call(ctx:, error_store:) ctx[:client].get(ctx[:url]) rescue Net::OpenTimeout =&gt; error error_store.add_error(:connection_error, error.message) end end . Now you can use these classes as a step|fail|pass step . class SomeActionConcat &lt; Decouplio::Action logic do step Concat end end action = SomeActionConcat.call(one: 1, two: 2) puts action[:result] # =&gt; 3 puts action # =&gt; # Result: success # Railway Flow: # Concat # Context: # {:one=&gt;1, :two=&gt;2, :result=&gt;3} # Errors: # {} . OR . class SomeActionSubtract &lt; Decouplio::Action logic do step :init_one step :init_two step Subtract end def init_one(param_one:, **) ctx[:one] = param_one end def init_two(param_two:, **) ctx[:two] = param_two end end action = SomeActionSubtract.call(param_one: 5, param_two: 2) puts action[:result] # =&gt; 3 puts action # =&gt; # Result: success # Railway Flow: # init_one -&gt; init_two -&gt; Subtract # Context: # {:param_one=&gt;5, :param_two=&gt;2, :one=&gt;5, :two=&gt;2, :result=&gt;3} # Errors: # {} . ",
    "url": "http://localhost:4000/decouplio.github.io/step_as_a_service/#how-to-use",
    "relUrl": "/step_as_a_service/#how-to-use"
  },"43": {
    "doc": "Wrap",
    "title": "Wrap",
    "content": "wrap is the type of step, that behaves like step, but can wrap several steps with block to make some pre/post actions or to rescue an error. ",
    "url": "http://localhost:4000/decouplio.github.io/wrap/",
    "relUrl": "/wrap/"
  },"44": {
    "doc": "Wrap",
    "title": "Signature",
    "content": "wrap(wrap_name, **options) do # steps to wrap end . ",
    "url": "http://localhost:4000/decouplio.github.io/wrap/#signature",
    "relUrl": "/wrap/#signature"
  },"45": {
    "doc": "Wrap",
    "title": "Behavior",
    "content": ". | all steps inside wrap step will be perceived as inner action. So depending on inner action result the wrap step will be move to success or failure track | . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one wrap :wrap_one do step :step_two fail :fail_one end step :step_three fail :fail_two end def step_one(param_for_step_one:, **) ctx[:step_one] = param_for_step_one end def step_two(param_for_step_two:, **) ctx[:step_two]= param_for_step_two end def fail_one(**) ctx[:fail_one] = 'Fail one failure' end def step_three(**) ctx[:step_three] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Fail two failure' end end success_wrap_success = SomeAction.call( param_for_step_one: true, param_for_step_two: true ) success_wrap_failure = SomeAction.call( param_for_step_one: true, param_for_step_two: false ) failure = SomeAction.call( param_for_step_one: false ) success_wrap_success # =&gt; # Result: success # Railway Flow: # step_one -&gt; wrap_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :param_for_step_two=&gt;true, :step_one=&gt;true, :step_two=&gt;true, :step_three=&gt;\"Success\"} # Errors: # {} success_wrap_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; wrap_one -&gt; step_two -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;true, :param_for_step_two=&gt;false, :step_one=&gt;true, :step_two=&gt;false, :fail_one=&gt;\"Fail one failure\", :fail_two=&gt;\"Fail two failure\"} # Errors: # {} failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :step_one=&gt;false, :fail_two=&gt;\"Fail two failure\"} # Errors: # {} . flowchart TD; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(wrap_one); subgraph wrap action; 3(wrap_one)--&gt;|success track|4(start); 4(start)--&gt;5(step_two); 5(step_two)--&gt;|success track|6(finish success); 5(step_two)--&gt;|failure track|9(fail_one); 9(fail_one)--&gt;|failure track|10(finish failure); end; 6(finish success)--&gt;|success track|7(step_three); 7(step_three)--&gt;|success track|8(finish success); 10(finish failure)--&gt;|failure track|11(fail_two); 11(fail_two)--&gt;|failure track|12(finish failure); 2(step_one)--&gt;|failure track|11(fail_two) . ",
    "url": "http://localhost:4000/decouplio.github.io/wrap/#behavior",
    "relUrl": "/wrap/#behavior"
  },"46": {
    "doc": "Wrap",
    "title": "Options",
    "content": "klass: some class, method: method to call on class . | Option | Requirements | Description | . | :klass | :method option | The class which implements method for wrap | . | :method | :klass option | The method which receives block as an argument | . EXAMPLE (CLICK ME) require 'decouplio' class WrapperClass def self.some_wrapper_method(&amp;block) if block_given? puts 'Before wrapper action execution' block.call puts 'After wrapper action execution' end end end class SomeActionWrapKlassMethod &lt; Decouplio::Action logic do wrap :wrap_one, klass: WrapperClass, method: :some_wrapper_method do step :step_one step :step_two end end def step_one(**) puts 'Step one' ctx[:step_one] = 'Success' end def step_two(**) puts 'Step two' ctx[:step_two] = 'Success' end end action = SomeActionWrapKlassMethod.call # =&gt; # Before wrapper action execution # Step one # Step two # After wrapper action execution action # =&gt; # Result: success # Railway Flow: # wrap_one -&gt; step_one -&gt; step_two # Context: # {:step_one=&gt;\"Success\", :step_two=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(wrap_one); subgraph wrap action; 2(wrap_one)--&gt;|success track|3(step_one); 3(step_one)--&gt;|success track|4(step_two); 4(step_two)--&gt;|success track|5(finish success); end; 5(finish success)--&gt;|success track|6(finish success) . on_success: . The same as for step . on_success: :finish_him . The same as for step . on_success: next success track step . The same as for step . on_success: next failure track step . The same as for step . on_success: :PASS . The same as for step . on_success: :FAIL . The same as for step . on_failure: . The same as for step . on_failure: :finish_him . The same as for step . on_failure: next success track step . The same as for step . on_failure: next failure track step . The same as for step . on_failure: :PASS . The same as for step . on_failure: :FAIL . The same as for step . on_error: any value allowed for on_success or on_failure . Behaves in the same way as on_error for step . if: condition method name . The same as for step . unless: condition method name . The same as for step . finish_him: :on_success . The same as for step . finish_him: :on_failure . The same as for step . ",
    "url": "http://localhost:4000/decouplio.github.io/wrap/#options",
    "relUrl": "/wrap/#options"
  }
}
