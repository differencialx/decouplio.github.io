{"0": {
    "doc": "Fail",
    "title": "Fail",
    "content": "fail is the special type of step to mark failure track . ",
    "url": "http://localhost:4000/decouplio/fail/",
    "relUrl": "/fail/"
  },"1": {
    "doc": "Fail",
    "title": "Signature",
    "content": "fail(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio/fail/#signature",
    "relUrl": "/fail/#signature"
  },"2": {
    "doc": "Fail",
    "title": "Behavior",
    "content": ". | when step method(#fail_one) returns truthy or falsy value then it goes to failure track(step_two step) if on_success: or on_failure: option wasn’t passed(see on_success, on_failure docs) | . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeAction.call(param_for_step_one: true) failure_action = SomeAction.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;true} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(finish_success); 2(step_one)--&gt;|failure track|4(fail_one); 4(fail_one)--&gt;|failure track|5(fail_two); 5(fail_two)--&gt;|failure track|F(finish_failure); . ",
    "url": "http://localhost:4000/decouplio/fail/#behavior",
    "relUrl": "/fail/#behavior"
  },"3": {
    "doc": "Fail",
    "title": "Options",
    "content": "on_success: . | Allowed values | Description | . | :finish_him | action stops execution if fail method returns truthy value | . | symbol with next step name | step with specified symbol name performs if step method returns truthy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_success: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessFinishHim &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :finish_him fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnSuccessFinishHim.call( param_for_step_one: true ) fail_step_success = SomeActionOnSuccessFinishHim.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnSuccessFinishHim.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;true} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(finish_success); 2(step_one)--&gt;|failure track|4(fail_one success); 2(step_one)--&gt;|failure track|7(fail_one failure); 4(fail_one success)--&gt;|failure track|5(finish_failure); 7(fail_one failure)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|5(finish_failure); . on_success: next success track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToSuccessTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :step_two step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnSuccessToSuccessTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnSuccessToSuccessTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnSuccessToSuccessTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one -&gt; step_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 2(step_one)--&gt;|failure track|6(fail_one failure); 5(fail_one success)--&gt;|success track|3(step_two); 6(fail_one failure)--&gt;|failure track|7(fail_two); 7(fail_two)--&gt;|failure track|8(finish_failure); . on_success: next failure track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToFailureTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :fail_three step :step_two fail :fail_two fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end end success_action = SomeActionOnSuccessToFailureTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnSuccessToFailureTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnSuccessToFailureTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_three=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_three); 6(fail_three)--&gt;|failure track|7(finish failure); 2(step_one)--&gt;|failure track|8(fail_one failure); 8(fail_one failure)--&gt;|failure track|9(fail_two); 9(fail_two)--&gt;|failure track|6(fail_three); . on_success: :PASS . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessPass &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_success: :PASS end def step_one(**) ctx[:step_one] = false end def fail_one(fail_one_param:, **) ctx[:fail_one] = fail_one_param end end fail_step_success = SomeActionOnSuccessPass.call(fail_one_param: true) fail_step_failure = SomeActionOnSuccessPass.call(fail_one_param: false) fail_step_success # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; true # :step_one =&gt; false # :fail_one =&gt; true # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; false # :step_one =&gt; false # :fail_one =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|failure track|3(fail_one); 3(fail_one)--&gt;|on_success: :PASS|5(finish_success); 3(fail_one)--&gt;|failure track|4(finish_failure); . on_success: :FAIL . It will perform like regular fail step, just move to next failure track step. on_failure: . | Allowed values | Description | . | :finish_him | action stops execution if fail method returns falsy value | . | symbol with next step name | step with specified symbol name performs if step method returns falsy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_failure: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureFinishHim &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :finish_him step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnFailureFinishHim.call( param_for_step_one: true ) fail_step_success = SomeActionOnFailureFinishHim.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnFailureFinishHim.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(finish failure); 2(step_one)--&gt;|failure track|8(fail_one failure); 8(fail_one failure)--&gt;|failure track|7(finish failure); . on_failure: next success track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToSuccessTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :step_two step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnFailureToSuccessTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnFailureToSuccessTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnFailureToSuccessTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one -&gt; step_two # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :step_two=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 8(fail_one failure)--&gt;|success track|3(step_two); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(finish_failure); 2(step_one)--&gt;|failure track|8(fail_one failure); . on_failure: next failure track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToFailureTrack &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :fail_three step :step_two fail :fail_two fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end end success_action = SomeActionOnFailureToFailureTrack.call( param_for_step_one: true ) fail_step_success = SomeActionOnFailureToFailureTrack.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionOnFailureToFailureTrack.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false, :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(fail_three); 7(fail_three)--&gt;|failure track|8(finish failure); 2(step_one)--&gt;|failure track|9(fail_one failure); 9(fail_one failure)--&gt;|failure track|7(fail_three); . on_failure: :PASS . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailurePass &lt; Decouplio::Action logic do step :step_one fail :fail_one, on_failure: :PASS end def step_one(**) false end def fail_one(fail_one_param:, **) ctx[:fail_one] = fail_one_param end end fail_step_success = SomeActionOnFailurePass.call(fail_one_param: true) fail_step_failure = SomeActionOnFailurePass.call(fail_one_param: false) fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; true # :fail_one =&gt; true # Errors: # {} fail_step_failure # =&gt; # Result: success # Railway Flow: # step_one -&gt; fail_one # Context: # :fail_one_param =&gt; false # :fail_one =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|failure track|3(fail_one); 3(fail_one)--&gt;|failure track|4(finish_failure); 3(fail_one)--&gt;|on_failure: :PASS|5(finish_success); . on_failure: :FAIL . It will perform like regular fail step, just move to next failure track step. if: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnIfCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two, if: :some_condition? fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end def some_condition?(if_condition_param:, **) if_condition_param end end success_action = SomeActionOnIfCondition.call( param_for_step_one: true ) fail_condition_positive = SomeActionOnIfCondition.call( param_for_step_one: false, if_condition_param: true ) fail_condition_negative = SomeActionOnIfCondition.call( param_for_step_one: false, if_condition_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_condition_positive # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;true, :action_failed=&gt;true, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} fail_condition_negative # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;false, :action_failed=&gt;true, :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|condition positive|6(fail_two); 6(fail_two)--&gt;|failure track|7(fail_three); 5(fail_one)--&gt;|condition negative|7(fail_three); 7(fail_three)--&gt;|failure track|8(finish failure); . unless: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnUnlessCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two, unless: :some_condition? fail :fail_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end def fail_three(**) ctx[:fail_three] = 'Failure' end def some_condition?(if_condition_param:, **) if_condition_param end end success_action = SomeActionOnUnlessCondition.call( param_for_step_one: true ) fail_condition_positive = SomeActionOnUnlessCondition.call( param_for_step_one: false, if_condition_param: false ) fail_condition_negative = SomeActionOnUnlessCondition.call( param_for_step_one: false, if_condition_param: true ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_condition_positive # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;false, :action_failed=&gt;true, :fail_two=&gt;\"Failure\", :fail_three=&gt;\"Failure\"} # Errors: # {} fail_condition_negative # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_three # Context: # {:param_for_step_one=&gt;false, :if_condition_param=&gt;true, :action_failed=&gt;true, :fail_three=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one); 5(fail_one)--&gt;|condition positive|6(fail_two); 6(fail_two)--&gt;|failure track|7(fail_three); 5(fail_one)--&gt;|condition negative|7(fail_three); 7(fail_three)--&gt;|failure track|8(finish failure); . finish_him: :on_success . The same behavior as for on_success: :finish_him . finish_him: :on_failure . The same behavior as for on_failure: :finish_him . finish_him: true . Will finish action execution anyway . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionFinishHimTrue &lt; Decouplio::Action logic do step :step_one fail :fail_one, finish_him: true step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(fail_one_param:, **) ctx[:action_failed] = fail_one_param end def step_two(**) ctx[:step_two] = 'Success' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionFinishHimTrue.call( param_for_step_one: true ) fail_step_success = SomeActionFinishHimTrue.call( param_for_step_one: false, fail_one_param: true ) fail_step_failure = SomeActionFinishHimTrue.call( param_for_step_one: false, fail_one_param: false ) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_two=&gt;\"Success\"} # Errors: # {} fail_step_success # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;true, :action_failed=&gt;true} # Errors: # {} fail_step_failure # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :fail_one_param=&gt;false, :action_failed=&gt;false} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 2(step_one)--&gt;|failure track|5(fail_one success); 5(fail_one success)--&gt;|failure track|6(finish failure); 2(step_one)--&gt;|failure track|7(fail_one failure); 7(fail_one failure)--&gt;|failure track|6(finish failure); . ",
    "url": "http://localhost:4000/decouplio/fail/#options",
    "relUrl": "/fail/#options"
  },"4": {
    "doc": "Step",
    "title": "Step",
    "content": "step is the basic type of logic steps . ",
    "url": "http://localhost:4000/decouplio/step/",
    "relUrl": "/step/"
  },"5": {
    "doc": "Step",
    "title": "Signature",
    "content": "step(step_name, **options) . ",
    "url": "http://localhost:4000/decouplio/step/#signature",
    "relUrl": "/step/#signature"
  },"6": {
    "doc": "Step",
    "title": "Behavior",
    "content": ". | when step method(#step_one) returns truthy value then it goes to success track(step_two step) | when step method(#step_one) returns falsy value then it goes to failure track(fail_one step) | . EXAMPLE (CLICK ME) require 'decouplio' class SomeAction &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end end success_action = SomeAction.call(param_for_step_one: true) failure_action = SomeAction.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true} # Errors: # {} . flowchart LR; A(start)--&gt;B(step_one); B(step_one)--&gt;|success track|C(step_two); B(step_one)--&gt;|failure track|D(fail_one); C(step_two)--&gt;|success track|E(finish_success); D(fail_one)--&gt;|failure track|F(finish_failure); . ",
    "url": "http://localhost:4000/decouplio/step/#behavior",
    "relUrl": "/step/#behavior"
  },"7": {
    "doc": "Step",
    "title": "Options",
    "content": "on_success: . | Allowed values | Description | . | :finish_him | action stops execution if step method returns truthy value | . | symbol with next step name | step with specified symbol name performs if step method returns truthy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_success: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessFinishHim &lt; Decouplio::Action logic do step :step_one, on_success: :finish_him fail :fail_one step :step_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end end success_action = SomeActionOnSuccessFinishHim.call(param_for_step_one: true) failure_action = SomeActionOnSuccessFinishHim.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;true} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(finish_success); 2(step_one)--&gt;|failure track|4(fail_one); 4(fail_one)--&gt;|failure track|5(finish_failure); . on_success: next success track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToSuccessTrack &lt; Decouplio::Action logic do step :step_one, on_success: :step_three fail :fail_one step :step_two step :step_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def step_three(**) ctx[:result] = 'Result' end end success_action = SomeActionOnSuccessToSuccessTrack.call(param_for_step_one: true) failure_action = SomeActionOnSuccessToSuccessTrack.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Result\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true} # Errors: # {} . flowchart LR; A(start)--&gt;B(step_one); B(step_one)--&gt;|success track|C(step_three); B(step_one)--&gt;|failure track|D(fail_one); C(step_three)--&gt;|success track|E(finish_success); D(fail_one)--&gt;|failure track|F(finish_failure); . on_success: next failure track step . Can be used if for some reason you need to jump to fail step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessToFailureTrack &lt; Decouplio::Action logic do step :step_one, on_success: :fail_two fail :fail_one step :step_two step :step_three fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:step_two] = 'Success' end def step_three(**) ctx[:result] = 'Result' end def fail_two(**) ctx[:fail_two] = 'Failure' end end success_action = SomeActionOnSuccessToFailureTrack.call(param_for_step_one: true) failure_action = SomeActionOnSuccessToFailureTrack.call(param_for_step_one: false) success_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :action_failed=&gt;true, :fail_two=&gt;\"Failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(fail_two); 2(step_one)--&gt;|failure track|4(fail_one); 4(fail_one)--&gt;|failure track|3(fail_two); 3(fail_two)--&gt;|failure track|5(finish_failure); . on_success: :PASS . It will perform like regular step, just move to next success track step. on_success: :FAIL . It will perform next failure track step OR finish action as failure in case if step is the last step. EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnSuccessFail &lt; Decouplio::Action logic do step :step_one step :step_two, on_success: :FAIL end def step_one(**) ctx[:step_one] = 'Success' end def step_two(step_two_param:, **) ctx[:step_two] = step_two_param end end success_action = SomeActionOnSuccessFail.call(step_two_param: true) failure_action = SomeActionOnSuccessFail.call(step_two_param: false) success_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; true # :step_one =&gt; \"Success\" # :step_two =&gt; true # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; false # :step_one =&gt; \"Success\" # :step_two =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_failure); 3(step_two)--&gt;|failure track|5(finish_failure); . on_failure: . | Allowed values | Description | . | :finish_him | action stops execution if step method returns falsy value | . | symbol with next step name | step with specified symbol name performs if step method returns falsy value | . | :PASS | will direct execution flow to nearest success track step. If current step is the last step when action will finish as success | . | :FAIL | will direct execution flow to nearest failure track step. If current step is the last step when action will finish as failure | . on_failure: :finish_him . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureFinishHim &lt; Decouplio::Action logic do step :step_one, on_failure: :finish_him fail :fail_one step :step_two fail :fail_two end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end end success_action = SomeActionOnFailureFinishHim.call(param_for_step_one: true) failure_action = SomeActionOnFailureFinishHim.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one # Context: # {:param_for_step_one=&gt;false} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|5(finish_success); 2(step_one)--&gt;|failure track|4(finish_failure); . on_failure: next success track step . Can be used in case if you need to come back to success track . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToSuccessTrack &lt; Decouplio::Action logic do step :step_one, on_failure: :step_three fail :fail_one step :step_two fail :fail_two step :step_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end end success_action = SomeActionOnFailureToSuccessTrack.call(param_for_step_one: true) failure_action = SomeActionOnFailureToSuccessTrack.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_three # Context: # {:param_for_step_one=&gt;false, :step_three=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(step_three); 4(step_three)--&gt;|success track|5(finish_success); 2(step_one)--&gt;|failure track|4(step_three); . on_failure: next failure track step . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailureToFailureTrack &lt; Decouplio::Action logic do step :step_one, on_failure: :fail_two fail :fail_one step :step_two fail :fail_two step :step_three end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end end success_action = SomeActionOnFailureToFailureTrack.call(param_for_step_one: true) failure_action = SomeActionOnFailureToFailureTrack.call(param_for_step_one: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} failure_action # =&gt; # Result: failure # Railway Flow: # step_one -&gt; fail_two # Context: # {:param_for_step_one=&gt;false, :fail_two=&gt;\"failure\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(step_three); 4(step_three)--&gt;|success track|5(finish_success); 2(step_one)--&gt;|failure track|6(fail_two); 6(fail_two)--&gt;|failure track|7(finish_failure); . on_failure: :PASS . It will perform next success track step OR finish action as success if it’s the last step. EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnFailurePass &lt; Decouplio::Action logic do step :step_one step :step_two, on_failure: :PASS end def step_one(**) ctx[:step_one] = true end def step_two(step_two_param:, **) ctx[:step_two] = step_two_param end end success_action = SomeActionOnFailurePass.call(step_two_param: true) failure_action = SomeActionOnFailurePass.call(step_two_param: false) success_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; true # :step_one =&gt; true # :step_two =&gt; true # Errors: # {} failure_action # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # :step_two_param =&gt; false # :step_one =&gt; true # :step_two =&gt; false # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|success track|3(step_two); 3(step_two)--&gt;|success track|4(finish_success); 3(step_two)--&gt;|failure track|5(finish_success); . on_failure: :FAIL . It will perform like regular step, just move to next failure track step. if: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnIfCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two step :step_three, if: :step_condition? end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end def step_condition?(step_condition_param:, **) step_condition_param end end condition_positive = SomeActionOnIfCondition.call( param_for_step_one: true, step_condition_param: true ) condition_negative = SomeActionOnIfCondition.call( param_for_step_one: true, step_condition_param: false ) condition_positive # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;true, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} condition_negative # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;false, :result=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|condition positive|3(step_two); 3(step_two)--&gt;|condition positive|4(step_three); 4(step_three)--&gt;|condition positive|5(finish_success); 2(step_one)--&gt;|condition negative|6(step_two); 6(step_two)--&gt;|condition negative|7(finish_success); . unless: condition method name . Can be used in case if for some reason step shouldn’t be executed . EXAMPLE (CLICK ME) require 'decouplio' class SomeActionOnUnlessCondition &lt; Decouplio::Action logic do step :step_one fail :fail_one step :step_two fail :fail_two step :step_three, unless: :step_condition? end def step_one(param_for_step_one:, **) param_for_step_one end def fail_one(**) ctx[:action_failed] = true end def step_two(**) ctx[:result] = 'Success' end def fail_two(**) ctx[:fail_two] = 'failure' end def step_three(**) ctx[:step_three] = 'Success' end def step_condition?(step_condition_param:, **) step_condition_param end end condition_positive = SomeActionOnUnlessCondition.call( param_for_step_one: true, step_condition_param: true ) condition_negative = SomeActionOnUnlessCondition.call( param_for_step_one: true, step_condition_param: false ) condition_positive # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;true, :result=&gt;\"Success\"} # Errors: # {} condition_negative # =&gt; # Result: success # Railway Flow: # step_one -&gt; step_two -&gt; step_three # Context: # {:param_for_step_one=&gt;true, :step_condition_param=&gt;false, :result=&gt;\"Success\", :step_three=&gt;\"Success\"} # Errors: # {} . flowchart LR; 1(start)--&gt;2(step_one); 2(step_one)--&gt;|condition positive|3(step_two); 3(step_two)--&gt;|condition positive|4(finish_success); 2(step_one)--&gt;|condition negative|5(step_two); 5(step_two)--&gt;|condition negative|6(step_three); 6(step_three)--&gt;|condition negative|7(finish_success); . finish_him: :on_success . The same behavior as for on_success: :finish_him . finish_him: :on_failure . The same behavior as for on_failure: :finish_him . ",
    "url": "http://localhost:4000/decouplio/step/#options",
    "relUrl": "/step/#options"
  }
}
